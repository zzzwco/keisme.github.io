<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SwiftUI 中的场景]]></title>
    <url>%2FSwiftUI-%E4%B8%AD%E7%9A%84%E5%9C%BA%E6%99%AF.html</url>
    <content type="text"><![CDATA[2022/08/29 Xcode 14 iOS 16 macOS 13 鉴于 Scene 比较特殊，难以在 Eul 中内置示例，笔者为其单独创建了一个样例工程，源码：Eul/SampleScene。 在《生命周期的演变》 中已经介绍过一些关于场景的概念了，下面逐一介绍 SwiftUI 内置的场景及其用法。 WindowGroup这是最重要、最常用的场景，新建一个 SwiftUI 工程时，在 app 入口处就会看到如下代码： 12345678@mainstruct MyAppApp: App &#123; var body: some Scene &#123; WindowGroup &#123; ContentView() &#125; &#125;&#125; WindowGroup 在不同的平台表现不一：在 iOS、watchOS 仅支持单窗口，iPadOS、macOS 支持多窗口。 比如在 Mac 下创建新窗口（系统默认快捷键为 ⌘ + N）： 在 iPad 中的多窗口界面： 在 app 入口处可以添加多个 scene，但只有第一个会被初始化并展示在界面上。比如示例中多个平台共用的 scene，在 app 启动后呈现的只有 MainWindow： 1234567891011121314151617181920212223242526272829303132struct SharedScene: Scene &#123; var body: some Scene &#123; WindowGroup("MainWindow") &#123; MainWindow() &#125; #if os(macOS) // 设置窗口默认尺寸 .defaultSize(width: 600, height: 1000) // 设置默认位置 .defaultPosition(.center) // 系统默认快捷键为 ⌘ + N，这里设置为 ⌘ + T .keyboardShortcut("t", modifiers: [.command]) #endif WindowGroup("WindowGroup1", id: "WindowGroup1", for: String.self) &#123; $value in Text(value ?? "WindowGroup1 没有传值") &#125; #if os(macOS) .keyboardShortcut("1", modifiers: [.command, .shift]) #endif WindowGroup("WindowGroup2", id: "WindowGroup2", for: String.self) &#123; $value in Text(value) &#125; defaultValue: &#123; "WindowGroup2 默认传值" &#125; #if os(macOS) .keyboardShortcut("2", modifiers: [.command, .shift]) #endif &#125;&#125; WindowGroup 有多个初始化方法，可以不添加任何参数直接通过闭包构建，也可以添加一至多个参数，具体就不一一例举了，读者可以对着苹果文档敲一遍。 上面的代码涉及到如下常用的参数： title：WindowGroup 的标题，支持字符串、本地化字符串、Text。 id：WindowGroup 的身份标识，使用 openWindow 时会根据 id 找到对应的 WindowGroup，如果已经存在 value 相同的窗口，则会将其前置，如果没有，则新建窗口。 for：遵循 Codable &amp; Hashable 协议，即 WindowGroup 接收到的传值类型。 $value：openWindow 通过环境变量传递过来的绑定值，其类型由 for 参数约束。 defaultValue：如果传值为 nil，该闭包可以指定一个与 for 参数类型一致的默认值。 这里提到了 openWindow，它其实是一个环境变量，在使用时先对其进行声明： 1@Environment(\.openWindow) private var openWindow 然后，在需要的地方调用 openWindow 方法就可以打开在 app 入口处声明过的 WindowGroup 了。刚才提到 openWindow 是一个变量，为何又能以方法的形式进行调用呢？那是因为它实现了 callAsFunction 方法，希望进一步了解的可以参考：SE-0253。 openWindow 有三个方法： openWindow(id:) openWindow(value:) openWindow(id:value:) 这里的 id 和 value 对应的就是 WindowGroup 的入参，只有数据类型保持一致，openWindow 才能正确地打开对应的 WindowGroup。 示例工程运行之后的界面如下，你可以根据以下两种操作来加深对 WindowGroup 的理解： 选择不同的方法和入参之后执行 openWindow。 直接使用快捷键 ⌘ + ⇧ + 1/2 分别打开 WindowGroup1 和 WindowGroup2。 另外，Xcode 新建的工程默认是支持多窗口的，如果要禁用 iPad 的多窗功能，可以 Target &gt; Info 中设置 Application Scene Manifest &gt; Enable Multiple Windows 为 No。 不过，这一做法对 Mac 是不生效的，但使用 Window 可以创建单窗口应用。 WindowWindow 只支持一个窗口，从命名上也很好区分它与 WindowGroup 的区别： WindowGroup 是一个组，它可以创建多个窗口，它们以标签页组的形式聚合在一起。 Window 是一个独立的窗口，它无法创建新窗口。 由于 Window 在程序运行时是唯一的实例，系统就没有必要为其指定 id 以示身份了。这也是为什么 openWindow 只支持 WindowGroup 的原因，因为 WindowGroup 需要区分不同的窗口并向其传递变量。 那么如何打开 Window 呢？我们看看示例代码： 12345// Window &gt; SingleWindow，或者使用快捷键 ⌘ + ⇧ + SWindow("SingleWindow", id: "SingleWindow") &#123; Text("I'm a single, unque window.")&#125;.keyboardShortcut("s", modifiers: [.command, .shift]) 在 app 入口处声明 Window 实例后，程序运行后可以通过菜单栏中的 Window &gt; SingleWindow 打开它。也可以为其指定快捷键，该快捷键也会显示在 Window 菜单中。 理解了 Window 之后，要创建一个单窗口的 mac 程序就非常简单了，只需要将 Window 实例声明为 app 的唯一场景即可。 SettingsSettings 只能在 mac 上使用，用于打开程序的设置界面，⌘ + , 是默认快捷键。 它也是一个单独的窗口，从表象上看，其实就是一个特殊的 Window。 MenuBarExtraMenuBarExtra 可以为程序在菜单栏中添加一个控件，支持 .menu 和 .window 两种样式。 如果想要创建一个只停留在 mac 菜单栏的 app，只需将 MenuBarExtra 实例作为 app 的唯一场景。不过，程序坞依然会出现 app 图标，此时需要在 Info.plist 中将属性 Application is agent (UIElement) 设置为 YES。 Settings 和 MenuBarExtra 的使用比较简单，这里就不展开来讲了，看看示例工程的运行效果和源码就可以明白。 DocumentGroupDocumentGroup 可以在多个平台上快速构建文件类型的场景界面，支持新建、打开、保存文件。 苹果官方有一个非常详细的样例，参考：Building a Document-Based App with SwiftUI。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swiftui</tag>
        <tag>scene</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的 Result builders]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84-Result-builders.html</url>
    <content type="text"><![CDATA[2022/08/30 Xcode 14 iOS 16 macOS 13 在以往的命令式编程中，通常这样构建视图： 123let label = UILabel()label.frame = self.view.boundsself.view.addSubview(label) 但 SwiftUI 采用的是声明式语法： 123456VStack &#123; Text("1") List &#123; Text("") &#125;&#125; 显而易见，SwiftUI 比 UIKit 要简洁地多，我们可以轻松地将不同的视图组合成复杂的界面。这得益于 Result builders（结果构造器），它使 SwiftUI 成为了特定领域语言（DSL）。 结果构造器是 Swift 5.4 正式引入的新特性，它可以将一系列子对象组合成新的对象，这个新对象又可以作为子对象去构造更复杂的对象。它在 SwiftUI 中无处不在，如构建场景的 @SceneBuilder，构建视图的 @ViewBuilder，还有 Swift 5.7 新增的正则构造器 RegexBuilder 等。 下面通过一个简单的示例来演示结果构造器的基本使用，假设我们想赋予 UIKit 类似 SwiftUI 的声明式语法，首先声明一个构造器： 123456@resultBuilder struct VStackBuilder &#123; static func buildBlock(_ components: UIView...) -&gt; [UIView] &#123; components &#125;&#125; 如上所示，要实现一个结果构造器，需要使用 @resultBuilder 修饰，并且必须实现 buildBlock 方法。 然后可以使用 @VStackBuilder 修饰相应的构造块（build block），如下的 VStack 会从 content 闭包构建视图： 1234567891011121314151617181920212223final class VStack: UIStackView &#123; @discardableResult init(superView: UIView, spacing: CGFloat = 10.0, @VStackBuilder content: () -&gt; [UIView]) &#123; super.init(frame: .zero) self.axis = .vertical self.spacing = spacing self.translatesAutoresizingMaskIntoConstraints = false content().forEach &#123; self.addArrangedSubview($0) &#125; superView.addSubview(self) NSLayoutConstraint.activate([ self.centerXAnchor.constraint(equalTo: superView.centerXAnchor), self.centerYAnchor.constraint(equalTo: superView.centerYAnchor), ]) &#125; required init(coder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125;&#125; 然后就可以愉快地使用 VStack 了： 12345678910111213141516171819202122232425262728293031323334353637class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() VStack(superView: self.view) &#123; UILabel() .text("Hello") .textColor(.orange) UILabel() .text("World") .textColor(.cyan) &#125; &#125;&#125;extension UILabel &#123; @discardableResult func text(_ text: String?) -&gt; Self &#123; self.text = text return self &#125; @discardableResult func font(_ font: UIFont) -&gt; Self &#123; self.font = font return self &#125; @discardableResult func textColor(_ textColor: UIColor) -&gt; Self &#123; self.textColor = textColor return self &#125;&#125; 如果需要在 VStack 中条件渲染视图，只需在相应的 VStackBuilder 中实现相应的静态方法 buildEither 即可： 1234567891011static func buildBlock(_ component: UIView) -&gt; UIView &#123; component&#125;static func buildEither(first component: UIView) -&gt; UIView &#123; component&#125;static func buildEither(second component: UIView) -&gt; UIView &#123; component&#125; 然后就可以这样写： 1234567VStack &#123; if Bool.random() &#123; UILabel().text("True") &#125; else &#123; UILabel().text("False") &#125;&#125; 关于结果构造器的更多细节和使用参考：SE-0289。 结果构造器使用简单，但效果神奇！它可以快速地实现 DSL，简化工作。 上例只实现了小部分构件 UI 的功能，并不具备数据绑定和更新状态的能力。此处仅为演示结果构造器的基本用法，并无指导意义。如果你的项目支持的最低版本为 iOS 13，可桥接使用 SwiftUI。 Github 有个仓库收集了许多 Result builders 的用法，参考：awesome-result-builders。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>SwiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的不透明类型、存在类型以及 some、any 关键字]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84%E4%B8%8D%E9%80%8F%E6%98%8E%E7%B1%BB%E5%9E%8B%E3%80%81%E5%AD%98%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A-some%E3%80%81any-%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[Xcode 14 beta 3 Swift 5.7 不透明类型、some 关键字some 关键字由 Swift 5.1 引入，它用来修饰某个协议，使之成为不透明类型。 不透明类型是隐藏类型信息的抽象类型，其底层的具体类型不可动态改变。 初次接触 SwiftUI 的读者会看到这样的代码： 123var body: some View &#123; Text("Hello")&#125; body 是不透明类型 some View，调用者只知其是一个遵循 View 协议的抽象类型，却不知其底层的具体类型（Text），因为不透明类型对调用者隐藏了类型信息。 这里的”不可见“是对调用者而言的，而编译器具有”透视“视角，它能够在编译期获取到不透明类型底层的具体类型（Text），并确保其底层类型是静态的。 如果在 body 内这样写： 1Bool.random() ? Text("Hello") : Image(systemName: "swift") 编译器能够诊断出 Text 和 Image 是不同的类型，因而抛出错误。假设 body 内部可以动态地改变其底层的具体类型，这意味着更多的内存占用和复杂计算，这会导致程序的性能损耗。 基于以上特性，不透明类型非常适合在模块之间调用，它可以保护类型信息为私有状态而不被暴露，而编译器能够访问类型信息并作出优化工作。 不透明类型受实现者约束，这和泛型受调用者约束是相反的。因此，不透明类型又被称为反向泛型。比如下面的代码： 1234567891011func build1&lt;V: View&gt;(_ v: V) -&gt; V &#123; v&#125;// v1 is Textlet v1 = build1(Text("Hello"))func build2() -&gt; some View &#123; Text("Hello")&#125;// v2 is Viewlet v2 = build2() 调用 build1 时就需要指定具体类型，此处入参为 Text 类型，因此 v1 的类型也是 Text。 build2 返回的具体类型由内部实现决定，这里返回的是 Text 类型。鉴于不透明类型对调用者隐藏了类型信息，因此 v2 的类型在编译期是 View，在运行时是 Text。 更优雅的泛型下面的代码用于比较两个集合，如果所有元素相同，返回 true。 12345678910111213141516func compare&lt;C1: Collection, C2: Collection&gt;(_ c1: C1, _ c2: C2) -&gt; Boolwhere C1.Element == C2.Element, C1.Element: Equatable &#123; if c1.count != c2.count &#123; return false &#125; for i in 0..&lt;c1.count &#123; let v1 = c1[c1.index(c1.startIndex, offsetBy: i)] let v2 = c2[c2.index(c2.startIndex, offsetBy: i)] if v1 != v2 &#123; return false &#125; &#125; return true&#125;let c1: [Int] = [1, 2, 3]let c2: Set&lt;Int&gt; = [1, 2, 3]let ans = compare(c1, c2) // true 这里使用泛型约束保证 C1 和 C2 是集合类型，使用 where 分句确保二者的关联类型 Element 是能够判等的相同类型。功能虽已实现，但写起来非常繁琐，也不利于阅读。那么，该如何简化呢？ 在简化之前，先来看看 Swift 5.7 新增的两个新特性： 使用范围更广的不透明类型 此前，不透明类型只能用于返回值。现在，我们还可以将其用于属性、下标以及函数参数。 主要关联类型 协议支持多个关联类型，使用尖括号声明（类似泛型写法）的则是主要关联类型。 如下 Collection 协议中的 Element，就是主要关联类型。 借助这一特性，在使用具有关联类型的协议时，写法可以非常简洁。比如上面的 where 分句，我们可以简写成 Collection&lt;Equatable&gt;。 123456public protocol Collection&lt;Element&gt; : Sequence &#123; associatedtype Element associatedtype Iterator = IndexingIterator&lt;Self&gt; ...&#125; 将以上两点结合起来，更优雅的写法如下： 123func compare&lt;E: Equatable&gt;(_ c1: some Collection&lt;E&gt;, _ c2: some Collection&lt;E&gt;) -&gt; Bool &#123; ...&#125; c1 和 c2 可以是任意集合类型，如果没有使用 some 标记，它就是下文提到的存在类型，编译器会提示使用 any 修饰。但这里将其声明为不透明类型，基于以下两点： 旧函数在调用时就已经确定了入参的具体类型，这和 any 的表达的意思有悖。 此处的不透明类型并没有用作返回值，只是在函数被调用时的入参，其具体类型是固定的，没有必要使用 any，这和旧函数表达的意图一致。 仔细对比两个函数，能够发现：some P 和 T where T: P 表达的意思其实是一样的。如果 P 带有关联类型 E，那么 T where T: P, T.E: V 可以简写为 some P&lt;V&gt;。 存在类型、any 关键字any 关键字由 Swift 5.6 引入，它用来修饰存在类型：一个能够容纳任意遵循某个协议的的具体类型的容器类型。 我们结合下面的代码来理解这段抽象的描述： 123456789101112protocol P &#123;&#125;struct CP1: P &#123;&#125;struct CP2: P &#123;&#125;func f1(_ p: any P) -&gt; any P &#123; p&#125;func f2&lt;V: P&gt;(_ p: V) -&gt; V &#123; p&#125; f1 中的 p 及其返回值都是存在类型，只要是遵循协议 P 的类型实例都是合法的。 f2 中的 p 及其返回值都不是存在类型，而是遵循协议 P 的某个具体类型。 在编译期间，f1 中 p 是存在类型（any P），它将 p 底层的具体类型包装在一个“容器”中。而在运行时，从容器中取出内容物才能得知 p 底层的具体类型。p 的类型可被任何遵循协议 P 的某个具体类型进行替换，因此存在类型具有动态分发的特性。 比如下面的代码： 123func f3() -&gt; any P &#123; Bool.random() ? CP1() : CP2()&#125; f3 的返回类型在编译期间是存在类型 any P，但是在运行期间的具体类型是 CP1 或 CP2。 而 f2 中的 p 没有被“容器”包装，无需进行装箱、拆箱操作。由于泛型的约束，当我们调用该方法时，就已经确定了它的具体类型。无论是编译期还是运行时，它的类型都是具体的，这又称为静态分发。比如这样调用时：f2(CP1()) ，入参和返回值类型都就已经固化为 CP1，在编译期和运行时都保持为该具体类型。 因为动态分发会带来一定的性能损耗，因此 Swift 引入了 any 关键字来向我们警示存在类型的负面影响，我们应该尽量避免使用它。 上面的示例代码不使用 any 关键字还能通过编译，但从 Swift 6 开始，当我们使用存在类型时，编译器会强制要求使用 any 关键字标记，否则会报错。 在实际开发中，推荐优先使用泛型和 some，尽可能地避免使用 any，除非你真的需要一个动态的类型。 文中涉及源码参考：Source code。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 5.7 新特性]]></title>
    <url>%2FSwift-5-7-%E6%96%B0%E7%89%B9%E6%80%A7.html</url>
    <content type="text"><![CDATA[Xcode 14 beta 3 Swift 5.7 简化的可选绑定（SE-0345）对可选类型解包时无需显式绑定，写法更简洁： 12345678910let s1: String? = "s1"if let s1 &#123; print(s1)&#125;guard let s1 else &#123; exit(0)&#125;print(s1) 更强大的类型推断默认表达式的类型推断（SE-0347）Swift 现在支持给泛型参数赋予默认值，并且能根据上下文推断泛型参数的具体类型。 12345func compute&lt;C: Collection&gt;(_ values: C = [0, 1, 2]) &#123; &#125;compute([1, 2, 3]) // [Int]compute(["a", "b", "c"]) // [String]compute([1, "2", &#123;&#125;]) // [Any] 多语句闭包的类型推断（SE-0326）以前的多语句闭包必须写明参数和返回值类型： 123456789let _ = [-1, 0, 1].map &#123; v -&gt; String in if v &lt; 0 &#123; return "negative" &#125; else if v &gt; 0 &#123; return "positive" &#125; else &#123; return "zero" &#125;&#125; 现在，编译器会自动推断： 123456789let _ = [-1, 0, 1].map &#123; if $0 &lt; 0 &#123; return "negative" &#125; else if $0 &gt; 0 &#123; return "positive" &#125; else &#123; return "zero" &#125;&#125; 更灵活的正则表达式正则类型（SE-0350）Swift 5.7 新增了正则类型 Regex&lt;Output&gt;，用于便捷地构建正则表达式。 12345678let s = "Stay hungry, stay foolish."let regex1 = try! Regex("[Ss]tay")let matches1 = s.matches(of: regex1)for match in matches1 &#123; let l = match.range.lowerBound let r = match.range.upperBound printLog(s[l..&lt;r])&#125; 正则构造器 DSL（SE-0351）正则表达式简洁有力，但难以书写。因此 Swift 提供了 DSL 供我们使用，便于方便地书写正则表达式。比如下面示例代码中的 OneOrMore(.word) 表达的意思和 /[A-Za-z0-9]+/ 是一样的。 1234567891011121314151617**import RegexBuilder**let regex2 = Regex &#123; "Stay " Capture &#123; OneOrMore(.word) // matches2.1 &#125; ", stay " Capture &#123; OneOrMore(.word) // matches2.2 &#125; "."&#125;if let matches2 = try regex2.wholeMatch(in: s) &#123; // matches2.0 是整个匹配的字符串 printLog(matches2.0, matches2.1, matches2.2)&#125; Regex 还支持使用别名和下标来获取匹配结果： 12345678910111213141516let ref1 = Reference(Substring.self)let ref2 = Reference(Substring.self)let regex3 = Regex &#123; "Stay " Capture(as: ref1) &#123; // res[ref1] OneOrMore(.word) &#125; ", stay " Capture(as: ref2) &#123; // res[ref2] OneOrMore(.word) &#125; "."&#125;if let matches3 = try regex3.wholeMatch(in: s) &#123; printLog(matches3[ref1], matches3[ref2])&#125; 另外，RegexBuilder 中的 buildPartialBlock 实现了基于结果生成器的重载。这是 SwiftUI 喜闻乐见的，因为此前的 ViewBuilder 最多只能从 10 个子 view 构建，但 buildPartialBlock 可以突破这个限制。这和 reduce 函数有点类似，在前一个生成的结果基础上，继续累积新的值。 更多相关 API 请查看：RegexBuilder。 正则字面量（SE-0354）Swift 支持使用字面量直接构建正则表达式，构建方式非常简单，只需要将表达式置于两个 / 之间： 1234567let regex4 = /[Ss]tay/let matches4 = s.matches(of: regex4)for match in matches4 &#123; let l = match.range.lowerBound let r = match.range.upperBound printLog(s[l..&lt;r])&#125; 字面量构建的正则表达式同样支持使用别名对匹配结果进行引用： 1234let regex5 = /Stay (?&lt;s1&gt;.+), stay (?&lt;s2&gt;[A-Za-z0-9]+)./if let matches5 = try regex5.wholeMatch(in: s) &#123; printLog(matches5.s1, matches5.s2)&#125; 值得注意的是，基于字符串构建的 Regex 类型必须在运行时才能对该字符串进行正确解析。而正则字面量在编译期就能被编译器诊断出错误，这也是我们应该优先使用正则字面量的原因。下面是 Regex 类型和字面量结合使用的示例： 1234567891011121314let regex6 = Regex &#123; "Stay" Capture &#123; // 空格使用使用\\转义 /\\ .+/ &#125; ", stay" Capture &#123; /\\ [A-Za-z0-9]+/ &#125; "."&#125;if let matches6 = try regex6.wholeMatch(in: s) &#123; printLog(matches6.1, matches6.2)&#125; 基于正则的字符串处理算法（SE-0357）除了上面提到的 matches(of:)、wholeMatch(in:)，Swift 中的集合类型许多原有的方法也提供了对 Regex 的支持。比如： 12printLog(s.replacing(/[Ss]tay/, with: "be"))printLog(s.contains(/\\ foo.+/)) 阐明了非隔离异步函数的执行（SE-0338）在此之前，在 g 中调用 f 时，f 可能会 actor 上执行并造成长时间的阻塞。 而现在所有的非隔离异步函数的执行，都会在全局的协作并发池上执行。当然，从 actor 切换至全局并发池执行时，程序依然会进行 Sendable 检查。比如，在 g 中调用 f 时，如果 c 没有实现 Sendable，编译器会发出警告。 12345678910111213class C &#123; &#125;// 总是在全局的协作并发池上执行func f(_: C) async &#123; &#125;actor A &#123; func g(c: C) async &#123; // 总是在 actor 上执行 print("on the actor") await f(c) &#125;&#125; 新的时间 API （SE-0329）Swift 5.7 提供了一种新的标准化时间组件，由以下三部分组成： Clock：基于 Clock 协议实现，是一种计算时间的机制，定义了现在以及将来某个指定的时间点唤醒工作的方式。 Instant：基于 InstantProtocol 协议实现，表示某个时间点。 Duration：基于 DurationProtocol 协议实现，表示两个时间点之间的间隔。 Clock 协议定义如下，其中的关联类型 Instant 遵循 InstantProtocol 协议，而另一个关联类型 Duration 和 InstantProtocol 协议中的 Duration: DurationProtocol 的类型保持一致： 12345678910111213@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)public protocol Clock : Sendable &#123; associatedtype Duration where Self.Duration == Self.Instant.Duration associatedtype Instant : InstantProtocol var now: Self.Instant &#123; get &#125; var minimumResolution: Self.Duration &#123; get &#125; func sleep(until deadline: Self.Instant, tolerance: Self.Instant.Duration?) async throws&#125; 系统内置了两种 Clock： ContinuousClock：系统睡眠时，仍能计时。 SuspendingClock：系统睡眠时，停止计时。 两种 Clock 使用方式一样，这里以 ContinuousClock 为例。比如用来计算某个同步操作的耗时： 12345let clock = ContinuousClock()let elapsed = clock.measure &#123; for _ in 0..&lt;999999 &#123;&#125;&#125;printLog("Loop duration: \\(elapsed)") Clock 还能用来计算异步事件的耗时，Task 也新增了对 Clock 的支持： 1234567891011func delayWork() async throws &#123; // tolerance 为容差，默认为 nil // 这里表示任务会睡眠 0.5 至 1 秒 let elapsed = try await clock.measure &#123; try await Task.sleep(until: .now + .seconds(0.5), tolerance: .seconds(0.5), clock: .continuous) &#125; printLog("Sleep duration: \\(elapsed)") printLog("Time is up, keep working...")&#125;try await delayWork() 如果任务在睡眠时间结束前就结束了，会抛出 CancellationError 类型的错误。 不透明类型增强了使用范围（SE-0341）此前，不透明类型只能用于返回值。现在，我们还可以将其用于属性、下标、函数参数以及结构化的返回类型（元组、数组、闭包等）。 123func tuple(_ v1: some View, _ v2: some View) -&gt; (some View, some View) &#123; (v1, v2)&#125; 主要关联类型以及轻量级同类型要求（SE-0346）协议支持多个关联类型，使用尖括号声明（类似泛型写法）的则是主要关联类型。 我们来看看 Collection 协议最新的定义： 123456public protocol Collection&lt;Element&gt; : Sequence &#123; associatedtype Element associatedtype Iterator = IndexingIterator&lt;Self&gt; ...&#125; 这里的 Element，就是主要关联类型。借助这一特性以及增强了使用范围的不透明类型，在使用具有主要关联类型的协议时，写法可以更优雅。比如下面这个用于比较两个集合的函数： 12func compare&lt;C1: Collection, C2: Collection&gt;(_ c1: C1, _ c2: C2) -&gt; Boolwhere C1.Element == C2.Element, C1.Element: Equatable &#123; &#125; 可以写得更简洁易读： 1func compare&lt;E: Equatable&gt;(_ c1: some Collection&lt;E&gt;, _ c2: some Collection&lt;E&gt;) -&gt; Bool &#123; &#125; 实际上，以前类似的泛型写法 T where T: P, T.E: V 一般都可以简写为 some P&lt;V&gt;。 关于存在类型的改进所有协议都可以作为存在类型使用（SE-0309）Swift 5.6 之前，我么经常遇到协议相关的编译错误： 1Protocol can only be used as a generic constraint because it has 'Self' or associated type requirements 通常我们的解决方法是将协议作为泛型约束来解决，Swift 5.6 为此引入了存在类型（一个能够容纳任意遵循某个协议的具体类型的容器类型），并新增了 any 关键字来进行标记。这一特性在 Swift 5.7 中全面解锁，所有的协议都可以使用 any 关键字来进行修饰。 值得注意的是，存在类型会导致性能损耗，any 关键字的主要作用其实是为了提醒我们它带来的潜在副作用，因此我们应该尽量避免使用它，除非你真的需要一个动态的类型。 隐式打开的存在的类型（SE-0352）前面我们提到存在类型是一种容器类型，它只有在运行时才能将容器打开获取到内部的具体类型。这会导致如下的代码报错： 1234567891011protocol P &#123; associatedtype A func getA() -&gt; A&#125;func takeP&lt;T: P&gt;(_ value: T) &#123; &#125;func test(p: any P) &#123; // error: protocol 'P' as a type cannot conform to itself takeP(p)&#125; 因为泛型约束，takeP 在入参时需要传入一个实现协议 P 的具体类型。而 test 中的 p 是存在类型，它是一个容器类型，其内部的具体类型可以动态改变，并且只有在运行时才能获取到真正的具体类型。所以，我们会看到如上的编译错误。 但现在这个错误不存在了，Swift 赋予了存在类型隐式打开的特性。在 test 中将 p 传入 takeP 时，p 容器内部的具体类型会被自动取出，然后被传递至 takeP 函数。这个自动拆箱的过程，有点类似可选类型中的隐式解包。 受约束的存在类型（SE-0353）具有主要关联类型的协议可以用于存在类型，通过主要关联类型对其进行约束。 比如我们将某个包含整数的集合转换称数组类型： 123func mapNumbers(_ c: any Collection&lt;Int&gt;) -&gt; [Int] &#123; c.map &#123; $0 &#125;&#125; 分布式 actor分布式 actor 主要用于服务端，有兴趣的读者可以参考：SE-0336、SE-0344。 本文仅是抛砖引玉，关于 Swift 5.7 更详细的变更请参考： Swift/CHANGELOG.md 文中涉及源码参考：Source code。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 5.6 新特性]]></title>
    <url>%2FSwift-5-6-%E6%96%B0%E7%89%B9%E6%80%A7.html</url>
    <content type="text"><![CDATA[不可用条件（#unavailable）#available 用于根据不同的平台、版本进行条件编译： 12345if #available(iOS 15, *) &#123; // 通配符 * 表示 Apple 所有平台，如果是 iOS，则要求 &gt;= 15&#125; else &#123; // iOS 15 以下&#125; Swift 5.6 引入了 #unavailable ，它和 #available 的意思正好相反，下面的示例和上面示例中的 else 分支表达的意思是一样的。 123if #unavailable(iOS 15) &#123; // iOS 15 以下&#125; 它也支持同时指定多个平台： 123if #unavailable(iOS 15, macOS 12) &#123; // iOS 15 以下， macOS 12 以下&#125; 注意：使用 #unavailable 使不需要通配符，我们的目的是为了使用它具体指出不可用的环境，使用 * 会造成歧义。 类型占位符（、 ?）Swift 5.6 支持使用占位符 _ 或 _? 表示需要声明的类型，我们无需显示地指定类型，编译器会根据上下文自行推断。 12345let complexType: [Int: _] = [1: [1], 2: [[2]], 3: [(1, 2)], 4: [&#123;&#125;]]// 编译器会将 complexType 的类型推断为 [Int : [Any]]let complexType: [Int: _] = [1: [1], 2: [[2]], 3: [(1, 2)], 4: nil]// 编译器会将 complexType 的类型推断为 [Int : [Any]?] CodingKeyRepresentable 协议先来看看下面的代码，我们想对字典进行编码，这个字典有点特殊，它的 key 是枚举类型。 1234567891011121314151617enum AnimalType: String, Codable &#123; case cat case dog&#125;struct Animal: Codable &#123; var name: String var age: String&#125;let pets: [AnimalType: Animal] = [ .cat: .init(name: "Mao", age: "3"), .dog: .init(name: "Biu", age: "2")]let petsData = try! JSONEncoder().encode(pets)print(String(decoding: petsData, as: UTF8.self))// ["cat",&#123;"name":"Mao","age":"3"&#125;,"dog",&#123;"name":"Biu","age":"2"&#125;] 打印的结果与预期不符，因为非 String/Int 类型的 key 值，Swift 在转换时无法正确处理。如果我们将这段编码后的字符串以 JSON 形式向服务端传参时，就会出现错误。为此，我们不得不做额外的工作来进行数据转换。 Swift 5.6 新增的 CodingKeyRepresentable 协议很好的解决了这个问题，它支持自定义 key 值的数据类型。我们让 AnimalType 遵循该协议，再次打印的结果与预期一致： 1// &#123;"dog":&#123;"name":"Biu","age":"2"&#125;,"cat":&#123;"name":"Mao","age":"3"&#125;&#125; any 关键字any 和 Any、AnyObject、AnyClass 很像，但它们的关系就像雷锋和雷峰塔。Any 开头的一般表示的是擦除类型信息的类型，any 是一个关键字，用来修饰一种特殊的类型：存在类型（existential types）。 存在类型是一个比较抽象的概念，如果一定要给它下个定义，我会这样描述它：作为类型的协议。比如下面的代码， 123456789101112131415protocol UIMode &#123; var color: Color &#123; get set &#125;&#125;struct LightMode: UIMode &#123; var color: Color = .white&#125;struct DarkMode: UIMode &#123; var color: Color = .black&#125;struct ModeManager &#123; var mode: UIMode&#125; 在 ModeManager 中 ，协议 UIMode 也被称作存在类型。我们使用一个 DarkMode() 实例来初始化 ModeManager 后，还可以使用 LightMode() 来替换原有的 mode。在编译期，mode 的类型是 UIMode。在运行时，mode 真正的类型是 LightMode、DarkMode 或其它任意遵循该协议的类型，它的值是可以动态分发的。 我们可以把存在类型的值想象成一个盒子，这个盒子可以动态地容纳所有符合该协议类型的值。只要是符合类型的值，相互之间可以动态替换。 我们将上面的代码结合泛型改造一下： 123456struct ModeManager&lt;T: UIMode&gt; &#123; var mode: T&#125;var manager = ModeManager(mode: DarkMode())manager.mode = LightMode() 这段代码是无法通过编译的，因为我们在初始化 ModeManager 时传入的是 DarkMode 类型，泛型在编译层面就已经将 mode 约束成了 DarkMode 类型，当我们使用 LightMode 类型的值去改变 mode 时，编译器会报错。 通过对比我们可以看出，当协议作为类型时，它也可以被称为存在类型。如果协议作为泛型的约束，它就无法在运行时动态改变其类型，相应的值只能静态分发。另外，不透明类型中使用 some 关键字修饰的协议，也无法使用不同类型，它要求我们始终使用遵循该协议的特定类型。 动态虽好，但效率不及静态。存在类型带来了性能损耗，但它是我们常用的写法。因此 Swift 5.6 引入了 any 关键字，目的就是提醒我们存在类型的负面影响。同时，我们应该尽可能地避免使用 any。 123struct ModeManager &#123; var mode: any UIMode&#125; 从 Swift 6 开始，当我们使用存在类型时，编译器会强制要求使用 any 关键字标记，否则会报错。 前文我们提到过，Any 开头的类型一般是擦除类型信息的。它具有一定的动态特性，但会带来一定的性能损耗。这个规律在 SwiftUI 中也是适用的，SwiftUI 中的 AnyView 我们也要慎用。但也不能一概而论，比如 AnyPublisher 我们还是会用到。因此，到底要不要擦除类型信息来换取一定的灵活性，我们要在性能和灵活之间作一个较为平衡的选择。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 并发新体验]]></title>
    <url>%2FSwift-%E5%B9%B6%E5%8F%91%E6%96%B0%E4%BD%93%E9%AA%8C.html</url>
    <content type="text"><![CDATA[引言对于诞生于 2014 年的 Swift 而言，它已不再年轻。至今我还记得初次体验 Swift 时的喜悦之情，比起冗长的 OC 而言，它更加现代、简洁、优雅。但 Swift 的前期发展是野蛮而动荡的，每次发布新版本时都会导致旧项目出现大量的报错和告警，项目迁移工作令开发者苦不堪言。不得不说，Swift 诞生之初就敢于在项目中实践并运用的人，是真的猛士。我是从 Swift 4 才开始将项目逐渐从 OC 向 Swift 迁移的，到 2019 年 Swift 5 实现了 ABI 稳定时，才全面迁移至纯 Swift 开发。 ABI 的稳定象征着 Swift 的成熟，然而在并发编程方面，Swift 却落后了一截。Chris Lattner 早在2017年发表的 《Swift 并发宣言》 中就描绘了令人兴奋的前景。2021 年 Swift 5.5 的发布终于将 Concurrency 加入了标准库，从此，Swift 并发编程变得更为简单、高效和安全。 在此之前，我们通常使用闭包来处理异步事件的回调，如下是一个下载网络图片的示例： 1234567891011func fetchImage(from: String, completion: @escaping (Result&lt;UIImage?, Error&gt;) -&gt; Void) &#123; URLSession.shared.dataTask(with: .init(string: from)!) &#123; data, resp, error in if let error = error &#123; completion(.failure(error)) &#125; else &#123; DispatchQueue.main.async &#123; completion(.success(.init(data: data!))) &#125; &#125; &#125;.resume()&#125; 代码并不复杂，不过这只是针对下载单一图片的场景。我们将需求设计的再复杂一点点：先下载前两张图片（无先后顺序）并展示，然后再下载第三张图片并展示，当三张图片都下载完成后，再展示在 UI 界面。当然，实际开发中一般是先下载的图片先展示，这里的非常规设计只作举例而已。 完整的实现代码变成如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import UIKitclass ViewController: UIViewController &#123; let sv = UIScrollView(frame: UIScreen.main.bounds) let imageViews = [UIImageView(), UIImageView(), UIImageView()] let from = [ "https://images.pexels.com/photos/10646758/pexels-photo-10646758.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500", "https://images.pexels.com/photos/9391321/pexels-photo-9391321.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500", "https://images.pexels.com/photos/9801136/pexels-photo-9801136.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500" ] override func viewDidLoad() &#123; super.viewDidLoad() sv.backgroundColor = .white view.addSubview(sv) sv.contentSize = .init(width: 0, height: UIScreen.main.bounds.height + 100) imageViews.enumerated().forEach &#123; i, v in v.backgroundColor = .lightGray v.contentMode = .scaleAspectFill v.clipsToBounds = true v.frame = .init(x: 0, y: CGFloat(i) * 220, width: UIScreen.main.bounds.width, height: 200) sv.addSubview(v) &#125; let group = DispatchGroup() let queue = DispatchQueue(label: "fetchImage", qos: .userInitiated, attributes: .concurrent) let itemClosure: (Int, DispatchWorkItemFlags, @escaping () -&gt; ()) -&gt; DispatchWorkItem = &#123; idx, flags, completion in return DispatchWorkItem(flags: flags) &#123; self.fetchImage(from: self.from[idx]) &#123; result in print(idx) switch result &#123; case let .success(image): self.imageViews[idx].image = image case let .failure(error): print(error) &#125; completion() &#125; &#125; &#125; from.enumerated().forEach &#123; i, _ in group.enter() let flags: DispatchWorkItemFlags = (i == 2) ? .barrier : [] queue.async(group: group, execute: itemClosure(i, flags, &#123; group.leave() &#125;)) &#125; group.notify(queue: queue) &#123; DispatchQueue.main.async &#123; print("end") &#125; &#125; &#125;&#125; 这里使用了 GCD 来实现需求，看上去也不是特别复杂，我们还能使用 PromiseKit 来管理事件总线，不直接编写 GCD 层面的代码，使代码更简洁更易读。但是试想一下，实际需求可能更复杂，我们也许要先从服务端获取一些数据后，再下载图片并进行解码以及缓存，同时可能还会有下载音频、视频等任务要处理，这样的情况就更加复杂了。不管有没有使用 PromiseKit 这样优秀的库，随着业务的复杂度增加，都无法回避会越来越明显地暴露出来的问题： 闭包本身难以阅读，还有导致循环引用的潜在风险 回调必须覆盖各种情况，一旦遗漏则难以排查问题所在 Result 虽然较好地处理了错误，但难以解决错误向上传递的问题 嵌套层级太深导致回调地狱 …… async/await 初体验针对上面的这些问题，Concurrency 的解决方案是使用 async/await 模式，该模式在 C#、Javascript 等语言中有着成熟的应用。现在，我们终于可以在 Swift 中使用它了！ 下面是使用 async/await 改造 fetchImage 的代码，这里先了解一下 async 和 await 关键字的基本使用： async：添加在函数末尾，标记其为异步函数 await：添加在调用 async 函数前，表明该处的代码会受到阻塞，直到异步事件返回 1234567891011121314func fetchImage(idx: Int) async throws -&gt; UIImage &#123; // 1 let request = URLRequest(url: .init(string: from[idx])!) // 2 let (data, resp) = try await URLSession.shared.data(for: request) // 3 print(idx, Thread.current) guard (resp as? HTTPURLResponse)?.statusCode == 200 else &#123; throw FetchImageError.badNetwork &#125; guard let image = UIImage(data: data) else &#123; throw FetchImageError.downloadFailed &#125; return image&#125; async throws 表明该函数是异步的、可抛出错误的 URLSession.shared.data 方法的全名如下，因此我们需要使用 try await 来调用该方法 1public func data(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -&gt; (Data, URLResponse) 代码执行到这里时，表明下载图片的异步事件已经结束了 相信你对 async/await 的使用已经有点感觉了：async 用来标记异步事件，await 用来调用异步事件，等待异步事件返回，然后继续执行后面的代码。它和 throws、try 这对关键词很像，几乎总是同时出现在相关场合。有的读者可能会纳闷，为何 try await 和 async throws 的顺序是反的，这里不必纠结，设计如此罢了，而且 try await 好像听上去和写起来更顺一点？ 接下来我们要做的就是调用异步函数 fetchImage，并且需要控制图片的下载顺序，实现代码： 123456789// 1async let image0 = try? fetchImage(idx: 0)async let image1 = try? fetchImage(idx: 1)// 2let images = await [image0, image1]imageViews[0].image = images[0]imageViews[1].image = images[1]// 3imageViews[2].image = try? await fetchImage(idx: 2) async let 可以让多个异步事件同时执行，这里表示同时异步下载前两张图片。 前面我们说了 async 用来标记异步函数，await 用来调用，几乎总是出现在同一场合。而且编译器会去检查调用 async 函数时是否使用了 await，如果没有，则会报错。而这里，我们在调用 fetchImage 时并没有使用 await，依然可以通过编译，是因为在使用 async let 时，如果我们没有显示地使用 try await，Swift 会隐式的实现它，而且能将 try await 的调用时机推迟。 上面的代码，我们将它改成如下也是可以的： 123async let image0 = fetchImage(idx: 0)async let image1 = fetchImage(idx: 1)let images = try await [image0, image1] await 阻塞当前任务，等待上面的两个异步任务返回结果 前两张图片下载完成之后，继续异步下载第三张图片并展示 将上面的代码放在 viewDidLoad 中执行，发现凡是有 async 的地方都报红了。这是因为如果某个函数内部调用了 async 函数，该函数也需要标记为 async，这样才能为函数体内部提供异步环境，并且将异步事件进行传递。而 viewDidLoad 没有被标记为 async，编译器发现了这一问题并报错了。但是，我们不能这样做。因为 viewDidLoad 是重写的 UIViewController 中的方法，它是运行在主线程中的同步函数而且必须如此。 那么这个问题该如何解决呢？Swift 为我们提供了 Task，在创建的 Task 实例闭包中，我们将获得一个新的异步环境，如此，就可以调用异步函数了。Task 就像打破同步环境结界的桥梁，为我们提供了通向异步环境的通道。 我们将上面的代码放在 Task 实例的闭包中，就可以顺利运行程序了。 1234567891011Task &#123; // 1 async let image0 = fetchImage(idx: 0) async let image1 = fetchImage(idx: 1) // 2 let images = try await [image0, image1] imageViews[0].image = images[0] imageViews[1].image = images[1] // 3 imageViews[2].image = try? await fetchImage(idx: 2)&#125; 上面的代码最终的表现结果和改造前还有点细微差别：前两张图片虽然是同时异步下载的，但是会相互等待，直到两张图片都下载完成后，才展示在界面上。这里提供两个思路去实现与之前同样的效果，一是将展示图片的逻辑放在 fetchImage 方法中，另一种是使用 Task 解决，参考代码如下： 12345678910Task &#123; let task1 = Task &#123; imageViews[0].image = try? await fetchImage(idx: 0) &#125; let task2 = Task &#123; imageViews[1].image = try? await fetchImage(idx: 1) &#125; let _ = await [task1.value, task2.value] imageViews[2].image = try? await fetchImage(idx: 2)&#125; 关于 Task、TaskGroup 并不在本文的讨论范畴，后面会有单独的章节去详述。 这里要补充说明的是，当我们使用 async let 时，实际上是在当前任务中隐式地创建了一个新的 task，或者叫子任务。async let 就像一个匿名的 Task，我们没有显示地创建它，也不能使用本地变量存储它。所以 Task 相关的 value、cancel() 等属性和方法，我们都无法使用。 async let 其实就是一个语法糖，我们可以使用它应对多数场景下的异步事件处理。如果要处理的异步事件数量多且关系复杂，甚至涉及到事件的优先级，那么使用 Task、TaskGroup 是更明智的选择。 Refactor to Async如果你想把之前基于回调的异步函数迁移至 async/await（最低支持 iOS 13），Xcode 内置了非常方便的操作，能够快速地进行零成本的迁移和兼容。 如图所示，选中相应的方法，右键选择 Refactor，会有三种选择： Convert Function to Async：将当前的回调函数转换成 async，覆盖当前函数 Add Async Alternative：使用 async 改写当前的回调函数，基于改写后的函数结合 Task 再提供一个回调函数 Add Async Wrapper：保留当前的回调函数，在此基础上提供一个 async 函数 从上我们可以得知 Wrapper 支持的 iOS 版本范围是大于 Alternative 的，我们可以根据项目的最低支持版本按需操作： &lt; iOS 13，选 3 &gt;= iOS 13 整体迁移至 async：选 1 保留回调函数 API：选 3 或 1 小结async/await 简化了异步事件的处理，我们无需和线程直接打交道，就可以写出安全高效的并发代码。回调机制经常衍生出的面条式代码也不复存在，我们可以用线性结构来清晰地表达并发意图。 这得益于结构化并发的编程范式在背后做理念支撑，结构化并发的思想和结构化编程是类似的。每个并发任务都有自己的作用域，并且有着明确且唯一的入口和出口。不管这个并发任务内部的实现有多复杂，它的出口一定是单一的。 我们把要执行并发任务想象成一根管道，水流就是管道内要执行的任务。在非结构化编程的世界，子任务会生成许多的管道分支，水流会从不同的分支出口流出去，也可能会遇到故障，我们需要在不同的出口去处理水流结果，出口越多，我们越手忙脚乱。而结构化编程的世界里，我们无需关心各个分支出口，只要守住管道另一端的唯一出口就可以了，分支出口不管多复杂，水流最终会回到管道的出口。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 协议的实战应用]]></title>
    <url>%2FSwift-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[Source code 随着 Swift 和 SwiftUI 的发展，协议所扮演的角色越来越重要，面向协议编程（POP）已成为日常开发的常规操作。本文不会细谈协议的基础概念（需要了解基础的同学，可以移步官方文档：Protocols），而是以实际案例来阐述协议的运用，希望读者能有所获益。 1、自定义 Button我们现在需要自定义一个按钮控件，要求可以快速生成不同样式的按钮，还能方便地维护和扩展。 我们首先定义一个协议，该协议只定义了一个方法 config(_:) 来配置按钮的样式： 1234protocol ButtonStyle &#123; func config(_ button: UIButton)&#125; 然后，我们定义一个按钮控件 Button，该类暴露了一个 style(_:) 方法来快速生成不同样式的按钮。Buton 的初始化方法里是该控件的一些公共配置，这里使用了笔者自己写的一个小工具来实现链式调用，方法名和系统 api 基本一致。 12345678910111213141516171819202122232425262728293031import KZRazorclass Button&lt;S: ButtonStyle&gt;: UIButton &#123; override var isHighlighted: Bool &#123; didSet &#123; self.alpha = isHighlighted ? 0.6 : 1.0 &#125; &#125; private var style: S? @discardableResult func style(_ style: S) -&gt; Self &#123; self.style = style style.config(self) return self &#125; override init(frame: CGRect) &#123; super.init(frame: frame) self.kz.padding(top: 8, bottom: 8, left: 16, right: 16) .kz.backgroundColor(.white) .kz.cornerRadius(8) .kz.titleColor(.darkText) &#125; required init?(coder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125;&#125; 我们现在来实现一个带模糊效果的按钮，定义一个遵循 ButtonStyle 协议的类并实现相应的方法： 1234567891011121314151617class BlurButtonStyle: ButtonStyle &#123; private var blurStyle: UIBlurEffect.Style init(blurStyle: UIBlurEffect.Style) &#123; self.blurStyle = blurStyle &#125; func config(_ button: UIButton) &#123; let blurEffect = UIBlurEffect(style: blurStyle) let blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.isUserInteractionEnabled = false button.kz.addSubview(blurEffectView) &#123; make in make.edges.equalToSuperview() &#125; &#125;&#125; 然后，我们就可以通过下面的方法来调用了： 1Button().style(BlurButtonStyle(blurStyle: .systemThinMaterialLight)).kz.title("Hello World!") 但是在写代码的时候不够智能，我们必须知道 ButtonStyle 的具体类型才能实现相应的 style，我们可以通过下面的改进来提供更友好的 api，在调用的时候，直接通过点语法就可以获得编译器的智能提示。 12345extension ButtonStyle where Self == BlurButtonStyle &#123; static func blur(style: UIBlurEffect.Style) -&gt; Self &#123; Self.init(blurStyle: style) &#125;&#125; 上面的调用代码就可以改写成： 1Button().style(.blur(style: .systemThickMaterialLight)).kz.title("Hello World!") 文章开头的图片还提供了 .automatic 和 .shadow 两种样式，思路与上面一致，参考代码如下： 123456789101112131415class DefaultButtonStyle: ButtonStyle &#123; func config(_ button: UIButton) &#123;&#125;&#125;extension ButtonStyle where Self == DefaultButtonStyle &#123; static var automatic: Self &#123; Self() &#125;&#125;class ShadowButtonStyle: ButtonStyle &#123; func config(_ button: UIButton) &#123;&#125;&#125;extension ButtonStyle where Self == ShadowButtonStyle &#123; static var shadow: Self &#123; Self() &#125;&#125; 对于 shadow 样式的按钮，为了获取到按钮的真实尺寸并添加阴影效果，我们在 Button 类重写 layoutSubViews 方法： 123456override func layoutSubviews() &#123; super.layoutSubviews() if self.style is ShadowButtonStyle &#123; self.kz.shadow(radius: 5, opacity: 0.1, color: .black, offset: .zero) &#125; &#125; 以上就是一个自定义按钮的实现，如果你熟悉 SwiftUI，就会发现这样的代码结构和 SwiftUI 中的各种视图的 style 实现思路是一致的。在遵循协议的基础上，我们可以放肆地修改和新增功能而将影响范围降至最小，这也意味着我们可以更好地理解我们的代码和进行单元测试。 我们并没有完全摒弃 OOP，而是与 POP 结合起来一起使用，都是为了更好地组织和管理代码。POP 并不能完全取代 OOP 这样的纵向继承方式，但它的横向扩展特性补充了 OOP 的不足。合纵连横，方为上策。 2、一个基础路由的实现 如上图，我们现在需要实现一个路由，通过路由来跳转到 A、B 界面，一个不带参数，一个带参数，同时，我们还需要能够在跳转过程中加入自定义转场动画。 首先，我们定义如下协议： 1234public protocol Routable &#123; var destination: UIViewController &#123; get &#125;&#125; Routable 协议只定义一个核心属性，就是路由跳转的控制器。这里我们并没有定义要跳转的方法，因为我们的需求是要在跳转过程中可以加入自定义转场动画，所以将跳转方法交给后文介绍的 Transition 协议来管理。 接着，我们定一个枚举类型，实现该协议。 12345678910111213141516enum Router1 &#123; case pageA case pageB(params: String)&#125;extension Router1: Routable &#123; var destination: UIViewController &#123; switch self &#123; case .pageA: return AController() case let .pageB(params): return BController(params: params) &#125; &#125;&#125; Router1 这里可以理解为某个功能模块，比如我们还有其它功能模块，可以依样画葫芦，将各个模块的业务实现组织在一起，方便管理和维护。比如，RouterAuth、RouterShop、RouterCart 等。 下一步我们实现一个单例类 Router，该类实现了 open 和 close 两个方法，分别用于界面的跳转和返回。 1234567891011121314class Router &#123; static let shared = Router() func open(_ target: Routable, transition: Transition, fromVc: UIViewController? = nil, completion: (() -&gt; Void)? = nil) &#123; // open &#125; func close(_ viewController: UIViewController?, transition: Transition, completion: (() -&gt; Void)? = nil) &#123; // close &#125;&#125; 路由的雏形基本出来了，接下来就是让 Transition 实例去实现 open 和 close 方法。根据这个思路，Transiton 协议定义如下： 1234567891011protocol Transition &#123; func open(_ viewController: UIViewController, fromVc: UIViewController?, completion: (() -&gt; Void)?) func close(_ viewController: UIViewController?, completion: (() -&gt; Void)?)&#125;extension Transition &#123; func open(_ viewController: UIViewController, fromVc: UIViewController?, completion: (() -&gt; Void)?) &#123;&#125; func close(_ viewController: UIViewController?, completion: (() -&gt; Void)?) &#123;&#125;&#125; 我们在 Router 中的 open 和 close 方法内加上 Transition 实例的调用方法，更新后的代码： 1234567891011121314class Router &#123; static let shared = Router() func open(_ target: Routable, transition: Transition, fromVc: UIViewController? = nil, completion: (() -&gt; Void)? = nil) &#123; transition.open(target.destination, fromVc: fromVc, completion: completion) &#125; func close(_ viewController: UIViewController?, transition: Transition, completion: (() -&gt; Void)? = nil) &#123; transition.close(viewController, completion: completion) &#125;&#125; 光有转场，没有动画，是转不起来的，所以我们需要给 Transition 协议新增如下两个属性（其中 animated 是用来标记是否需要动画的，以应对不需要动画的场景）： 12var animated: Bool &#123; get set &#125;var animator: Animator? &#123; get set &#125; Animator 协议继承自系统的 UIViewControllerAnimatedTransitioning 协议： 1234protocol Animator: UIViewControllerAnimatedTransitioning &#123; var duration: TimeInterval &#123; get set &#125;&#125; 接下来，我们来实现一个渐变的 Push。如果你熟悉自定义转场，那么下面的代码就很好理解了。 UIApplication.navigationController 是通过 extension 实现的一个小功能，用来获取 app 当前的导航控制器，方便我们在非控制器界面获取导航控制器，读者不必纠结具体实现。 123456789101112131415161718192021222324252627282930313233343536373839404142final class PushTransition: NSObject, Transition &#123; var animated: Bool = true var animator: Animator? private weak var fromVc: UIViewController? private var navigationController: UINavigationController? &#123; if fromVc != nil &#123; return fromVc!.navigationController &#125; return UIApplication.navigationController &#125; init(animator: Animator?, animated: Bool) &#123; self.animator = animator self.animated = animated &#125; func open(_ viewController: UIViewController, fromVc: UIViewController?, completion: (() -&gt; Void)?) &#123; self.fromVc = fromVc navigationController?.delegate = self CATransaction.begin() CATransaction.setCompletionBlock(completion) navigationController?.pushViewController(viewController, animated: animated) CATransaction.commit() &#125;&#125;extension Transition where Self == PushTransition &#123; static func push(animator: Animator?, animated: Bool = true) -&gt; Self &#123; Self(animator: animator, animated: animated) &#125;&#125;extension PushTransition: UINavigationControllerDelegate &#123; func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; animator &#125;&#125; 我们只差最后一步的动画了，前面我们已经定了 Animator 协议，现在我们实现一个 FadeAnimator： 1234567891011121314151617181920212223242526final class FadeAnimator: NSObject, Animator &#123; var duration: TimeInterval = 0.25 init(duration: TimeInterval = 0.25) &#123; self.duration = duration &#125; func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; duration &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; guard let toView = transitionContext.view(forKey: .to) else &#123; return &#125; let containerView = transitionContext.containerView containerView.addSubview(toView) toView.alpha = 0 UIView.animate(withDuration: duration) &#123; toView.alpha = 1.0 &#125; completion: &#123; _ in transitionContext.completeTransition(!transitionContext.transitionWasCancelled) &#125; &#125;&#125; 代码很简单，除了实现我们自己定义的 duration 属性，还需要实现 UIViewControllerAnimatedTransitioning 的协议方法。 我们的工作已接近尾声，现在尝试调用一下： 123456789Router.shared.open( Router1.pageB(params: textView.text), transition: .push(animator: FadeAnimator(duration: 2)), fromVc: nil) &#123; print("Did push") &#125;// animator 传参，这里是直接使用的 FadeAnimator 实例// 笔者尝试过使用 extenstion Animator 的方式增加点语法调用，比如 .fade(duration: 2)// 编译器始终无法通过。。。这里作了妥协，如果有更优雅的实现，欢迎交流 结果和预期一致： 同理，对于 pop 操作，我们也可以用同样的思路实现，这里就不展开来说了，有兴趣的读者可以参看源码。 至此，一个基础的路由就实现了。如果需要实现更为复杂的功能比如 Universal Links 跳转、加入手势驱动转场等，读者可自行研究和实现。 Source code]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Protocol</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 协议属性和方法的默认实现]]></title>
    <url>%2FSwift-%E5%8D%8F%E8%AE%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[协议是 Swift 中头等重要的内容，在实际开发中，我们会大量地使用面向协议编程。 方法的默认实现一个协议中可能会定义许多的属性和方法，有些属性和方法却不是遵循该协议的对象必须实现的，又或者，我们不希望在每个遵循该协议的对象中写入过多重复的代码。 我们可以给协议的属性和方法添加默认的实现来解决上面的问题，我们先来看看方法的默认实现。 第一种方式是使用 @objc 来实现： 12345678910@objc protocol Human &#123; @objc optional func read() func eat()&#125;class Man: Human &#123; func eat() &#123;&#125;&#125; Human 协议定义了两个方法，其中 eat 为必须实现的，而 read 并不是必须的，使用 @objc optional 表明该方法为可选。然后我们让 Man 这个类遵循 Human 协议，只需要实现 eat 方法即可。 第二种实现方式是使用 extension 给协议添加一个默认实现方法： 123456789101112131415protocol Human &#123; func read() func eat()&#125;extension Human &#123; func read() &#123;&#125;&#125;struct Man: Human &#123; func eat() &#123;&#125;&#125; 我们在协议扩展中默认实现了 read 方法，因此在结构体 Man 中就无需实现该方法了。 注意这里我将 Man 的类型从 class 改为了 struct ，这样是没有问题的。但是如果我们在第一种实现方式中，将 Man 的类型从 class 改为 struct，编译器就会报错。 因为使用 @objc 标记的协议，只有遵循 NSObject 的 class 类才能遵循该协议，这也是它的局限性所在。比如 struct 、enum 都不能遵循该协议，关联类型更是无法在该协议中使用。 使用 extension 为协议添加默认实现虽然需要多写点代码，但却摆脱了上面的限制，笔者个人习惯使用第二种实现方式，这也是笔者推荐的方式。 属性的默认实现我们给 Human 添加一个属性 age 和 height，然后添加一个新的结构体 Woman ，代码变成如下： 12345678910111213141516171819202122protocol Human &#123; var age: Int &#123; get set &#125; var heigth: CGFloat &#123; get set &#125; func read() func eat()&#125;extension Human &#123; func read() &#123;&#125;&#125;struct Man: Human &#123; func eat() &#123;&#125;&#125;struct Woman: Human &#123; func eat() &#123;&#125;&#125; 毫不意外，编译器报错了，因为 Man 和 Woman 没有实现协议中的 age 和 height 属性，我们当然可以在 Man 和 Woman 中实现这两个属性，但是如果还有其它遵循 Human 协议的结构体，我们不想在每个结构体中都把这两个属性实现一遍，而是希望能有个默认值。那么该如何实现呢？很遗憾 extension 无法实现我们的需求，我们需要另辟蹊径。 在软件设计中，许多问题都可以通过添加中间层来实现。这里我们可以借鉴这个思路，先定义一个如下结构体将各个属性包装起来： 12345struct HumanProperties &#123; var age: Int = 0 var height: CGFloat = 30.0&#125; 然后我们在 Human 协议中添加一个属性： 123456protocol Human &#123; var hp: HumanProperties &#123; get set &#125; func read() func eat()&#125; 然后我们在扩展中添加属性： 1234567891011121314extension Human &#123; var age: Int &#123; get &#123; hp.age &#125; set &#123; hp.age = newValue &#125; &#125; var height: CGFloat &#123; get &#123; hp.height &#125; set &#123; hp.height = newValue &#125; &#125; func read() &#123;&#125;&#125; 然后在遵循 Human 协议的结构体中实现 hp 属性： 1234567891011struct Man: Human &#123; var hp = HumanProperties() func eat() &#123;&#125;&#125;struct Woman: Human &#123; var hp = HumanProperties() func eat() &#123;&#125;&#125; 不管 Human 有多少属性要实现，我们都可以使用 HumanProperties 包装起来，并且为之提供了默认值。 方法参数的默认值我们为 eat 方法添加如下参数： 1func eat(breakfast: String, lunch: String, dinner: String) 假设我们现在正在健康饮食阶段，想给 breakfast 和 dinner 添加两个默认值来约束 Man 的行为。 遗憾的是，协议方法并不支持带默认值的参数。 我们可以故技重施，将上面的参数包装起来： 12345struct Recipe &#123; var breakfast: String = "Bread &amp; Milk" var lunch: String var dinner: String = "Fruits"&#125; 然后将方法修改为： 1func eat(_ food: Recipe) 接着实现该方法： 123456789struct Man: Human &#123; var hp = HumanProperties() func eat(_ food: Recipe) &#123; print(food) &#125;&#125; 调用： 12var p = Man()p.eat(.init(lunch: "Rice &amp; Beef &amp; Vegetables"))]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Protocol</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI、Combine 简明教程 App：Eul]]></title>
    <url>%2FSwiftUI%20%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%20App%EF%BC%9AEul.html</url>
    <content type="text"><![CDATA[简介Eul 是一款 SwiftUI、Concurrency 简明教程 App（支持 iPhone、iPad、Mac），以文章（文字、图片、代码）配合真机示例（Xcode 13+、iOS 15+，macOS 12+）的形式呈现给读者。 笔者意在尽可能使用简洁明了的语言阐述 SwiftUI、Concurrency、Combine 相关的知识，使读者能快速掌握并在 iOS 开发中实践。读者若能从中获益，笔者深感欣慰。如有笔误之处，恳请斧正，不甚感激。 下面是 App 内实图： iOS： macOS： 下载链接iOS/macOS：AppStore 联系反馈 邮箱：zzzwco@outlook.com 微博：zzzwwco twitter：zzzwco]]></content>
      <categories>
        <category>Products</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Products</tag>
        <tag>App</tag>
        <tag>Eul</tag>
        <tag>Combine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI PreferenceKey]]></title>
    <url>%2FSwiftUI-PreferenceKey.html</url>
    <content type="text"><![CDATA[下图所示是一个常规的登录界面，只需少量代码即可实现： 123456789101112131415161718192021struct ContentView : View &#123; @State private var email = "" @State private var password = "" var body: some View &#123; Form &#123; HStack &#123; Text("电子邮箱") TextField("请输入", text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) &#125; HStack &#123; Text("密码") TextField("请输入", text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) &#125; &#125; &#125;&#125; 但是通常我们为了美观，会将左边的文字列等宽对齐，也许固定宽度是个不错的想法，但是可扩展性太差，我们如何解决这个问题呢？ 常规的思路就是，获取文字列所有的内容的宽度，取最大值，重绘界面即可。那么问题来了，如何获取这个最大值呢？答案就是 PreferenceKey，它可以收集视图树中子视图的数据，回传给父视图（跨层级亦可）。这里我们需要获取尺寸，还用到了 GeometryReader。 改造后的效果和代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct ContentView : View &#123; @State private var email = "" @State private var password = "" // 保存、更新文字列所需要的合适宽度，这里是最大值 @State private var textWidth: CGFloat? var body: some View &#123; Form &#123; HStack &#123; Text("电子邮箱") .frame(width: textWidth, alignment: .leading) .background(TextBackgroundView()) TextField("请输入", text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) &#125; HStack &#123; Text("密码") .frame(width: textWidth, alignment: .leading) .background(TextBackgroundView()) TextField("请输入", text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) &#125; &#125; .onPreferenceChange(TextWidthPreferenceKey.self) &#123; (value) in print(value) textWidth = value.max() &#125; &#125;&#125;struct TextBackgroundView: View &#123; var body: some View &#123; GeometryReader &#123; gr in Rectangle() .fill(Color.clear) .preference(key: TextWidthPreferenceKey.self, value: [gr.size.width]) &#125; &#125;&#125;struct TextWidthPreferenceKey: PreferenceKey &#123; // 偏好值没有被设定时，使用默认值 static var defaultValue: [CGFloat] = [] // 收集视图树中的数据 // nextValue 的闭包是惰性调用的，只有需要用到它时才会去获取相应的值 static func reduce(value: inout [CGFloat], nextValue: () -&gt; [CGFloat]) &#123; value.append(contentsOf: nextValue()) &#125;&#125; 有一点需要注意，为什么我们要使用 TextBackgroundView 来作为背景回传所需要的值呢？因为我们期望 Form 列表的布局是根据子视图的布局来更新的，而子视图又依赖父视图传入的宽度值，这样形成了一个得不到结果的死循环。而 TextBackgroundView 可以打破这个僵局，父视图所依赖的布局不再是文字的布局，而是背景层的视图布局。 补充说明一下，SwiftUI 的视图层级是不同于 UIKit 的，在 UIKit 中，背景是控件的属性，而 SwiftUI 中，.background 会在视图树中生成一个新的视图，是独立与所修饰的控件的。 另外有一点令我不解的是，既然我是要获取最大宽度，只需要在 TextWidthPreferenceKey 将关联类型设置为 CGFloat 即可，在 reduce 方法中写入 value = max(value, nextValue())，然后在 onPreferenceChange 中将最大值传给 textWidth ，这样不是更简单吗？但是事与愿违，这样达不到我们想要的效果，观察控制台，我发现确实可以获取到最大宽度值，但是不会更新视图布局，百思不得其解，网上也没找到合理的解释。暂且放下，以后再研究一下这个问题。 参考： PreferenceKey’s reduce method demystified Inspecting the View Tree – Part 1: PreferenceKey SwiftUI 小技巧：透過 PreferenceKey 簡單對齊視圖]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swiftui</tag>
        <tag>PreferenceKey</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI GeometryReader 与坐标系]]></title>
    <url>%2FSwiftUI-GeometryReader-%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB.html</url>
    <content type="text"><![CDATA[GeometryReader 是一个通过闭包来构建视图的容器，可以返回一个 GeometryProxy 类型的结构体，它包含如下属性和方法，由此我们可以获取当前视图容器（即父视图）的尺寸和位置，绘制以其为参考坐标系的视图。 12345678var safeAreaInsets: EdgeInsets// The safe area inset of the container view.var size: CGSize// The size of the container view.func frame(in: CoordinateSpace) -&gt; CGRect// Returns the container view’s bounds rectangle, converted to a defined coordinate space. 比如，我们需要绘制一个长宽均为父视图一半的矩形： 12345678910struct ContentView: View &#123; var body: some View &#123; GeometryReader &#123; gr in RoundedRectangle(cornerRadius: 10) .fill(Color.blue) .frame(width: gr.size.width * 0.5, height: gr.size.height * 0.5) .position(x: gr.frame(in: .local).midX, y: gr.frame(in: .local).midY) &#125; &#125;&#125; 我们再来看看 GeometryProxy 包含的实例方法：func frame(in: CoordinateSpace) -&gt; CGRect，这里的 CoordinateSpace 是个枚举类型，有以下几种情况： 123case global // 参考系为屏幕case local // 参考系为父视图case named(AnyHashable) // 参考系为自定义 通过这个方法，我们可以获取到当前视图在不同参考系中的位置和尺寸，我们将代码改成如下： 123456789101112131415161718192021222324252627282930313233343536373839struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 10) &#123; text("Top", width: 100, height: 50) HStack(spacing: 10) &#123; text("Left", width: 50, height: 100) roundRect .background(Color.black) text("Right", width: 50, height: 100) &#125; text("Bottom", width: 100, height: 50) &#125; .coordinateSpace(name: "VStack") &#125; var roundRect: some View &#123; GeometryReader &#123; gr in RoundedRectangle(cornerRadius: 10) .fill(Color.blue) .frame(width: gr.size.width * 0.5, height: gr.size.height * 0.5) .position(x: gr.frame(in: .local).midX, y: gr.frame(in: .local).midY) .onTapGesture &#123; print("screen: \(UIScreen.main.bounds)") print("global: \(gr.frame(in: .global))") print("local: \(gr.frame(in: .local))") print("custom: \(gr.frame(in: .named("VStack")))") &#125; &#125; &#125; func text(_ text: String, width: CGFloat, height: CGFloat) -&gt; some View &#123; Text(text) .frame(width: width, height: height) .background(Color.orange) .cornerRadius(10) &#125;&#125; 运行模拟器 iPhone 12 Pro（safeAreaInsets: 47.0, 0.0, 34.0, 0.0），点击蓝色区域，控制台打印如下结果： 1234screen: (0.0, 0.0, 390.0, 844.0)global: (60.0, 107.0, 270.0, 643.0)local: (0.0, 0.0, 270.0, 643.0)custom: (60.0, 60.0, 270.0, 643.0) 这与我们之前所说的枚举类型对应的坐标参考系是一致的。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swiftui</tag>
        <tag>GeometryReader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的协议、泛型、不透明类型]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E4%B8%8D%E9%80%8F%E6%98%8E%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[在学习 SwiftUI 的过程中，发现对标题中的内容还不甚熟悉，而这些内容是 SwiftUI 中极其重要的部分，不理解就很难熟练地掌握 SwiftUI，故温习并记录，以下内容可视为官方教程的简装版。 协议定义协议规定了实现某一特定功能的方法和属性。 类、结构体、枚举类型都可以遵循协议。 语法123protocol SomeProtocol &#123; // 协议内容&#125; 属性要求属性可以是存储型或计算型，必须明确其可读写性。 12345protocol Cat &#123; var food: String &#123; get set &#125; // 可读写 var color: Color &#123; get &#125; // 只读 static var age: Int &#123; get &#125; // static 用于 class 的类型属性&#125; 方法要求方法可以是实例方法或类方法，方法参数不能使用默认值。 异变方法要求协议中的实例方法可以标记为 mutating，当结构体、枚举这样的值类型实现相应的方法时，需要加上 mutating 关键字，而类作为引用类型，不需要该关键字。 初始化器要求协议可以要求遵循者实现指定的初始化器，只是不需要写初始化器的实体，即大括号里的内容。 1234protocal Cat &#123; init(from: String) init?(color: Color) // 可失败的初始化器&#125; 协议初始化器要求的类实现在遵循协议的类中实现的构造器，可以指定为类的指定构造器或便利构造器，在这两种情况下，必须使用 required 修饰构造器。该修饰符保证：所有遵循该协议的子类，都能有一个明确的继承实现。 123456789101112protocol P &#123; init()&#125;class SomeSuperClass &#123; init() &#123;&#125;&#125;class SomeSubClass: SomeSuperClass, P &#123; // SomeSubClass 遵循协议 P，所以要用 required 修饰 required override init &#123;&#125;&#125; 将协议作为类型使用场合： 在函数、方法或者初始化器里作为形参类型或者返回类型 作为常量、变量或者属性的类型 作为数组、字典或者其他存储器的元素的类型 123456789101112131415161718192021222324252627282930313233343536protocol LifeStyle &#123; func lifeStyle() -&gt; [String]&#125;class Person &#123; var name: String var lifeStyle: LifeStyle init(name: String, lifeStyle: LifeStyle) &#123; self.name = name self.lifeStyle = lifeStyle &#125; func beBetterFrom() -&gt; [String] &#123; return lifeStyle.lifeStyle() &#125; func perf(with addition: String) -&gt; [String] &#123; var newStyle = lifeStyle.lifeStyle() newStyle.append(addition) return newStyle &#125;&#125;struct Recommend: LifeStyle &#123; func lifeStyle() -&gt; [String] &#123; return ["read", "travel"] &#125;&#125;let p = Person(name: "p", lifeStyle: Recommend())print(p.beBetterFrom())/// ["read", "travel"]let newStyle = p.perf(with: "love")print(newStyle)/// ["read", "travel", "love"] 在扩展里添加协议遵循扩展可以补充协议中已存在的内容，或是提供默认的实现，还可以给协议新增内容。 有条件的遵循协议123extension Array where Element: Equatable &#123; // code&#125; 使用扩展声明采纳协议如果一个类型已经遵循类协议的要求，但是还没有声明采纳协议，可以通过一个空的扩展来显式地声明它采纳协议。 1234567891011struct Hamster &#123; var name: String var textualDescription: String &#123; return "A hamster named \(name)" &#125;&#125;extension Hamster: TextRepresentable &#123;&#125;let simonTheHamster = Hamster(name: "Simon")let somethingTextRepresentable: TextRepresentable = simonTheHamsterprint(somethingTextRepresentable.textualDescription) 协议类型的集合1234let things: [TextRepresentable] = [game, d12, simonTheHamster]for thing in things &#123; print(thing.textualDescription)&#125; 协议继承123protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123; // protocol definition goes here&#125; 类专用的协议123protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol &#123; // class-only protocol definition goes here&#125; 协议组合12345678910111213141516protocol Named &#123; var name: String &#123; get &#125;&#125;protocol Aged &#123; var age: Int &#123; get &#125;&#125;struct Person: Named, Aged &#123; var name: String var age: Int&#125;func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123; print("Happy birthday, \(celebrator.name), you're \(celebrator.age)!")&#125;let birthdayPerson = Person(name: "Malcolm", age: 21)wishHappyBirthday(to: birthdayPerson)// Prints "Happy birthday, Malcolm, you're 21!" 协议遵循的检查 如果实例遵循协议 is 运算符返回 true 否则返回 false as? 版本的向下转换运算符返回协议的可选项，如果实例不遵循这个协议的话值就是 nil as! 版本的向下转换运算符强制转换协议类型并且在失败是触发运行时错误 可选协议要求 略 协议扩展略 泛型类型形式参数1func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) 占位符 T 就是类型形式参数，当我们调用函数时，用实际类型来替换类型形参。 ## 泛型类型Swift 允许自定义泛型类型，它们可以使自定义类、结构体、枚举。 123456789struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125; 扩展一个泛型类型12345extension Stack &#123; var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125; 类型约束类型约束语法123func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // function body goes here&#125; 类型约束的应用12345678func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 关联类型定义一个协议时，声明一个或多个关联类型是很有用的。关联类型个协议中用到的类型一个占位符名称，直到采纳协议时，才指定实际类型。 关联类型的应用1234567891011121314151617181920212223242526272829protocol Container &#123; associatedtype ItemType mutating func append(_ item: ItemType) var count: Int &#123; get &#125; subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125;struct Stack&lt;Element&gt;: Container &#123; var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // 可省略，应为 Swift 可以推断出此处的关联类型 // typealias ItemType = Element mutating func append(_ item: Element) &#123; self.push(item) &#125; var count: Int &#123; items.count &#125; subscript(i: Int) -&gt; Element &#123; return items[i] &#125;&#125; 给关联类型添加约束123456protocol Container &#123; associatedtype Item: Equatable mutating func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125;&#125; 在关联类型约束里使用协议123456789101112131415161718192021protocol SuffixableContainer: Container &#123; associatedtype Suffix: SuffixableContainer where Suffix.Item == Item func suffix(_ size: Int) -&gt; Suffix&#125;extension Stack: SuffixableContainer &#123; func suffix(_ size: Int) -&gt; Stack &#123; var res = Stack() for i in (count-size)..&lt;count &#123; res.append(self[i]) &#125; return res &#125;&#125;var stackOfInts = Stack&lt;Int&gt;()stackOfInts.append(10)stackOfInts.append(20)stackOfInts.append(30)print(stackOfInts.suffix(2))// "Stack&lt;Int&gt;(items: [20, 30])" 扩展现有类型来指定关联类型Swift 中的 Array 类型已经提供了 Container 协议中的方法和属性，我们只需要用一个空的扩展显示地声明采纳协议即可： 1extension Array: Container &#123;&#125; 现在我们可以把任何 Array 当做一个 Container 使用。 泛型 Where 分句12345678910func allItemsMatch&lt;C1: Container, C2: Container&gt;( _ c1: C1, _ c2: C2) -&gt; Bool where C1.Item == C2.Item &#123; if c1.count != c2.count &#123; return false &#125; for i in 0..&lt;c1.count &#123; if c1[i] != c2[i] &#123; return false &#125; &#125; return true&#125; 带有泛型 Where 分句的扩展123456789extension Container where Item == Double &#123; func average() -&gt; Double &#123; var sum = 0.0 for i in 0..&lt;count &#123; sum += self[i] &#125; return sum / Double(count) &#125;&#125; 泛型下标1234567891011extension Container &#123; // 传入的 indices 形参是一个整数的序列 subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item] where Indices.Iterator.Element == Int &#123; var res = [Item]() for i in indices &#123; res.append(self[i]) &#125; return res &#125;&#125; 不透明类型具有不透明返回类型的函数或者方法会隐藏它返回值的具体类型信息，而以它支持的协议进行描述。隐藏类型信息在模块之间调用代码时很好用，因为返回值的具体类型可以保持私有。不同于返回一个协议类型的值，不透明类型保持了类型的身份——编译器可以访问类型信息，但是模块不能。 不透明类型也可以理解为“反向泛型”，泛型受调用者约束，而不透明类型受被调用者约束。 函数不能返回带有 Self 或 associatedtype 的协议，而不透明类型可以。函数可以返回不同的协议类型，不透明类型每次必须返回相同的类型。 12345678910111213141516171819202122232425262728293031323334353637383940protocol UIMode &#123; func color() -&gt; UIColor&#125;struct LightMode: UIMode &#123; func color() -&gt; UIColor &#123; return .white &#125;&#125;struct DarkMode: UIMode &#123; func color() -&gt; UIColor &#123; return .black &#125;&#125;let light = LightMode()let dark = DarkMode()func getMode(isDay: Bool) -&gt; UIMode &#123; isDay ? light : dark&#125;print(getMode(isDay: true).color())print(getMode(isDay: false).color())struct AutoMode: UIMode &#123; var isDay: Bool func color() -&gt; UIColor &#123; isDay ? .white : .black &#125;&#125;func getModeOpaque(isDay: Bool) -&gt; some UIMode &#123; return AutoMode(isDay: isDay)&#125;print(getModeOpaque(isDay: true).color())print(getModeOpaque(isDay: false).color())]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swiftui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI（iOS 14）新增属性包装器（Property Wrapper）]]></title>
    <url>%2FSwiftUI%EF%BC%88iOS-14%EF%BC%89%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%85%E5%99%A8%EF%BC%88Property-Wrapper%EF%BC%89.html</url>
    <content type="text"><![CDATA[@StateObject@StateObject 修饰的对象与 @ObservedObject 一样，都需要遵循 Observable 协议，功能也类似。区别在于，@StateObject 修饰的对象只会在所属的 View 中创建一次并在 View 的生命周期内存储相应的状态，而 @ObservedObject 修饰的对象会随着 View 的重绘生成新的对象，不会在 View 的生命周期内存储该对象的状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Counter: ObservableObject &#123; @Published var count: Int = 0&#125;struct StateObjectView: View &#123; @State private var buttonTitle = "Tap me" var body: some View &#123; VStack &#123; Group &#123; Button(buttonTitle) &#123; buttonTitle = buttonTitle == "Tap me" ? "Tapped" : "Tap me" &#125; CounterView1() CounterView2() &#125; .padding() &#125; &#125;&#125;struct ItemList: View &#123; @State private var items = ["hello", "world"] var body: some View &#123; VStack &#123; Button("Append item to list") &#123; items.append("test") &#125; List(items, id: \.self) &#123; name in Text(name) &#125; CounterView1() CounterView2() &#125; &#125;&#125;struct CounterView1: View &#123; @StateObject var counter1 = Counter() var body: some View &#123; VStack &#123; Text("StateObject count: \(counter1.count)") Button("IncrementStateObject") &#123; counter1.count += 1 &#125; &#125; &#125;&#125;struct CounterView2: View &#123; @ObservedObject var counter2 = Counter() var body: some View &#123; VStack &#123; Text("ObservedObject count: \(counter2.count)") Button("IncrementStateObject") &#123; counter2.count += 1 &#125; &#125; &#125;&#125; 如上代码所示，当我们点击 CounterView1 和 CounterView2 中的按钮时，会给相应的 Counter 实例的 count 属性加 1，一旦我们点击 “Tap me” 按钮，View 会执行重绘，这时 CounterView2 中的 count 会重置为 0，而 CounterView1 中使用 @StateObject 修饰的对象中的 count 仍然持有当前的数据状态。 那么我们应该在什么场景下分别使用这两个属性包装器呢？ 在 View 的生命周期内，需要一直持有并存储对象的状态时，使用 @StateObject 修饰。基本上，绝大多数情况下的 viewModel 都会是这种情况。 只有在少数情况下，View 不需要一直持有该对象，该对象的状态会随着外界的条件改变而刷新自己时，我们才用到 @ObservedObject 修饰，比如上面的例子，如果我们要求点击 “Tap me” 按钮时，count 就重置，就需要用 @ObservedObject 修饰了。 @AppStorage等同于 Userdefaults。 @SceneStorage用于多窗口模式，相当于为每个场景持久化了一个场景值，每个场景只能读取该场景持久化的值。 当场景销毁时，该值也会销毁。建议存储轻量的、不敏感的数据。 @UIApplicationDelegateAdaptor用来调用 AppDelegate 中的生命周期方法。 1234567891011121314class AppDelegate: NSObject, UIApplicationDelegate &#123; &#125;@mainstruct MyApp: App &#123; @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate var body: some Scene &#123; WindowGroup &#123; ContentView() &#125; &#125;&#125; 其它参考之前的文章SwiftUI 中常见的属性包装器（Property Wrapper）概览和今天这篇，只是列举了一些常用的，更多相关内容和使用方法可以参考下面两片佳作： swiftuipropertywrappers All SwiftUI property wrappers explained and compared Source code]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swiftui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI 中常见的属性包装器（Property Wrapper）概览]]></title>
    <url>%2FSwiftUI-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%85%E5%99%A8%EF%BC%88Property-Wrapper%EF%BC%89%E6%A6%82%E8%A7%88.html</url>
    <content type="text"><![CDATA[​ Demo @State由 SwiftUI 管理的可读写的属性包装器，当修饰的属性值改变的时候，界面会随之更新。由 @State 包装的属性通常用 private 修饰，在 body 内使用。 下面的实例是一个可以切换天气的界面，并且可以控制天气是否可变。 1234567891011121314151617181920212223242526272829303132333435363738394041424344enum Weather: String, CaseIterable &#123; case sun = "Sun" case cloud = "Cloud" case rain = "Rain" case snow = "Snow" var imageName: String &#123; switch self &#123; case .sun: return "sun.max" case .cloud: return "cloud" case .rain: return "cloud.rain" case .snow: return "snow" &#125; &#125;&#125;struct StateView: View &#123; @State private var weather: Weather = .sun @State private var mutableWeather = false var body: some View &#123; VStack &#123; Toggle(isOn: $mutableWeather) &#123; Text(mutableWeather ? "Mutable" : "Immutable") &#125; .padding() // add weather view Spacer() &#125; .navigationBarTitle("Weather", displayMode: .inline) .navigationBarItems(trailing: Button(action: &#123; if self.mutableWeather &#123; let random = Int.random(in: 0..&lt;Weather.allCases.count) self.weather = Weather.allCases[random] &#125; &#125;) &#123; Text(weather.rawValue) &#125;) &#125;&#125; @Binding接下来，我们用自定义的 WeatherView 去展示天气图片，图片会跟随父视图天气变化做相应改变，并且在 WeatherView 中可以通过点击改变天气。这个时候，我们就需要用到 @binding 来做数据的双向绑定。 12345678910111213141516struct WeatherView: View &#123; @Binding var weather: Weather @Binding var mutableWeather: Bool var body: some View &#123; Image(systemName: weather.imageName) .resizable() .scaledToFill() .frame(width: 150, height: 150) .onTapGesture &#123; self.mutableWeather = true let random = Int.random(in: 0..&lt;Weather.allCases.count) self.weather = Weather.allCases[random] &#125; &#125;&#125; 接下来我们在 // add weather view下面添加如下代码： 1WeatherView(weather: $weather, mutableWeather: $mutableWeather) @ObservedObject、@Published、ObservableObject遵循 ObservableObject 协议的类的属性可以用 @Published 包装，在多个界面之间同步数据，只需要将需要监听的实例对象用 @ObservedObject 包装即可。注意：这里适用的对象类型是 class，因为 class 是在内存中共享数据的。 下面是一个可以编辑一个人姓名和年龄的实例，在 EditView 所做的更改，会同步至 Person 界面。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person: ObservableObject &#123; @Published var name: String @Published var age: Int init(name: String, age: Int) &#123; self.name = name self.age = age &#125;&#125;struct EditView: View &#123; @ObservedObject var person: Person var body: some View &#123; // TextField 只能绑定 String，需要自定义 Binding let bindingAge = Binding&lt;String&gt;(get: &#123; "\(self.person.age)" == "0" ? "" : "\(self.person.age)" &#125;) &#123; value in self.person.age = Int(value) ?? 0 &#125; return Form &#123; TextField("Input name", text: $person.name) TextField("Input age", text: bindingAge) &#125; &#125;&#125;struct ObservedObjectView: View &#123; @ObservedObject private var person = Person(name: "Bruce", age: 30) var body: some View &#123; List &#123; Text(person.name) Text("\(person.age)") &#125; .navigationBarTitle("Person", displayMode: .inline) .navigationBarItems(trailing: NavigationLink(destination: EditView(person: self.person)) &#123; Text("Edit") &#125; ) &#125;&#125; @Environment、EnvironmentValues@Environment 可以让我们在 View 中直接访问预设的环境变量，比如系统是否暗黑模式、系统日历、时区等。 下面是一个可以返回上一个页面的实例，@Environment将.presentationMode绑定在当前的 View，我们可以直接调用presentationMode来获取它的值： 123456789struct EnvironmentView: View &#123; @Environment(\.presentationMode) private var presentationMode var body: some View &#123; Button("Dismiss") &#123; self.presentationMode.wrappedValue.dismiss() &#125; &#125;&#125; 系统为我们提供了许多有用的预设变量，详见 https://developer.apple.com/documentation/swiftui/environmentvalues 我们也可以为预设值注入新值，比如我们将返回按钮标题改为 “Dismiss\nDismiss”，这时可以看见一个换行的按钮，而当我们给.lineLimit注入新值得时候，按钮标题就只有一行了： 1234Button("Dismiss\nDismiss") &#123; self.presentationMode.wrappedValue.dismiss()&#125;.environment(\.lineLimit, 1) 这里只是举个例子，我们使用.lineLimit(1)也能达到同样的效果。 我们也可以自定义 EnvironmentValues： 12345678910struct DismissColorKey: EnvironmentKey &#123; public static let defaultValue = Color.red&#125;extension EnvironmentValues &#123; var dismissColor: Color &#123; set &#123; self[DismissColorKey.self] = newValue &#125; get &#123; self[DismissColorKey.self] &#125; &#125;&#125; 然后我们添加一个新的属性： 1@Environment(\.dismissColor) private var dismissColor 再使用自定义的预设值添加一个红色的返回按钮： 123456Button(action: &#123; self.presentationMode.wrappedValue.dismiss()&#125;) &#123; Text("Red Dismiss") .foregroundColor(dismissColor)&#125; @EnvironmentObject@EnvironmentObject 和 @ObservedObject 很像，都需要遵循 ObservableObject 协议，都可以同步数据状态，但是它具备更强大的功能，那就是子视图可以自动获取父视图注入的环境变量。 比如我们有如下视图层级：A -&gt; B -&gt; C -&gt; D -&gt; E，后一个是前一个视图的子视图。如果我们使用 @ObservedObject 在 A 视图包装一个变量，我们需要在每个视图包装一个变量，将变量一层层传递到 E 视图。而使用 @EnvironmentObject 我们不需要这么复杂，我们在 A 视图声明一个变量后，在 E 视图用 @EnvironmentObject 包装一个变量后，就可以获取到 A 视图注入的环境变量了，而且可以同步数据的修改，这简直是太方便了。要注意的是，如果 E 视图找不到这个环境变量，程序会崩溃，所以要确保 E 视图能获取到注入的环境变量。 12345678910111213141516171819202122232425262728293031323334353637class User: ObservableObject &#123; @Published var name = "Bruce"&#125;struct ViewA: View &#123; var body: some View &#123; ViewB() .frame(width: 300, height: 300) .background(Color.red) &#125;&#125;struct ViewB: View &#123; var body: some View &#123; ViewC() .frame(width: 200, height: 200) .background(Color.black) &#125;&#125;struct ViewC: View &#123; @EnvironmentObject var user: User var body: some View &#123; Text(user.name) .frame(width: 100, height: 100) .background(Color.white) &#125;&#125;struct EnvironmentObjectView: View &#123; private let user = User() var body: some View &#123; ViewA().environmentObject(user) &#125;&#125; ​ Demo]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swiftui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App Store 提交审核被拒记录]]></title>
    <url>%2FApp-Store-%E6%8F%90%E4%BA%A4%E5%AE%A1%E6%A0%B8%E8%A2%AB%E6%8B%92%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[ITMS-90809: Deprecated API Usage最近提交的 App 遇到了这个问题，邮件中提到的是被废弃的 UIWebView API，在工程中全局搜索后没有找到 UIWebView。想来必然是第三方静态库使用了，在工程目录下使用命令grep -r UIWebView .查看哪些库使用了 UIWebView，移除或升级相关库即可。 ITMS-90381: Too many symbol files项目本身设置了 Valid Architecture 为 arm64、arm64e，但是因为使用了支持 32 位设备的三方库，所以生成了冗余的 symbols 文件。 查询 symbols 文件的生成情况：Xcode Window -&gt; Organizer 选择有问题的 archive，右击选择 Show in finder，命令行进入 .app 中的 dSYMs 文件夹，执行 `dwarfdump –uuid ` 可以查询到是否生成了多余的文件。 解决方法是在 Podfile 中添加如下内容： 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['DEBUG_INFORMATION_FORMAT'] = 'dwarf' end endend 在platform :ios, &#39;12.0&#39;这一行下面添加即可，然后重新pod install --verbose。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>App Store</tag>
        <tag>审核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter PATH（fish shell）设置和镜像设置]]></title>
    <url>%2FFlutter-PATH%EF%BC%88fish-shell%EF%BC%89%E8%AE%BE%E7%BD%AE%E5%92%8C%E9%95%9C%E5%83%8F%E8%AE%BE%E7%BD%AE.html</url>
    <content type="text"><![CDATA[如果你在 Mac 下使用的 fish shell，按照官方教程设置 flutter 的路径是不会永久生效的。解决方法如下： vi ~/.config/fish/config.fish 写入如下内容： 1set PATH &lt;flutter安装路径&gt;/flutter/bin $PATH 使用echo $PATH查看，发现已经生效，即使退出终端再次打开，依然能正常使用 flutter 的相关命令。 安装好 flutter 后，使用flutter doctor命令，结果一直卡住不动了。。。后来才明白是 TC 的网络问题，参考官方的设置镜像即可。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>mirror</tag>
        <tag>path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftFormat 的使用]]></title>
    <url>%2FSwiftFormat-%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[虽然 Xcode 自带格式对齐（Ctrl + i），但是在多人协作的情况下，就很难保证编码风格的统一了，SwiftFormat就是解决这一问题的好工具。 SwiftFormat具有多种使用方式，目前我在实际工作中使用的是CocoaPods集成。具体使用方法： pod &#39;SwiftFormat/CLI&#39;，安装 SwiftFormat TARGETS - Build Phases - New Run Script Phase，添加如下脚本： 1"$&#123;PODS_ROOT&#125;/SwiftFormat/CommandLineTool/swiftformat" . --exclude Pods,Generated 在编译或运行的时候，SwiftFormat会对齐不符合格式的代码。Enjoy it~]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 创建自定义文件模板]]></title>
    <url>%2FXcode-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"><![CDATA[首先，创建我们的自定义模板文件夹： 1mkdir -p ~/Library/Developer/Xcode/Templates/Custom 然后复制系统提供的模板文件，路径如下： 1/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/Swift File.xctemplate 将Swift File.xctemplate整个文件夹复制到刚才创建的Custom文件夹。 然后我们开始自定义，只需要修改___FILEBASENAME___.swift中的内容即可。 其中涉及到一些宏定义可以参考：Text macros reference。注意：宏定义前后必须加上三个下划线。 然后我们就可以使用了，如图：]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 Xcode 文件头部注释]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89-Xcode-%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E6%B3%A8%E9%87%8A.html</url>
    <content type="text"><![CDATA[首先，用 Xcode 创建一个 plist 文件：IDETemplateMacros.plist。 在新建的 plist 文件中，添加键值对。key 为 FILEHEADER，value 参考 IDETemplateMacros.plist中的内容。 其中，FILENAME、PACKAGENAME等为宏定义，更多宏定义请可以通过 Xcode - Help 搜索“Text macros reference”获得。这里要注意的是，宏定义的前后必须要加上三个下划线。 然后我们将编辑好的 plist 文件放入指定的路径，关于路径有以下选择，对应不同的作用范围： Project - 某个用户 1&lt;ProjectName&gt;.xcodeproj/xcuserdata/[username].xcuserdatad/ Project - 所有用户 1&lt;ProjectName&gt;.xcodeproj/xcshareddata/ Workspace - 某个用户 1&lt;WorkspaceName&gt;.xcworkspace/xcuserdata/[username].xcuserdatad/ Workspace - 所有用户 1&lt;WorkspaceName&gt;.xcworkspace/xcshareddata/ Xcode -全局 1~/Library/Developer/Xcode/UserData/ 所有的工作已经完成了，试试创建一个新的文件看看效果吧！]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卸载 CocoaPods（Uninstall CocoaPods）]]></title>
    <url>%2F%E5%8D%B8%E8%BD%BD-CocoaPods%EF%BC%88Uninstall-CocoaPods%EF%BC%89.html</url>
    <content type="text"><![CDATA[使用命令卸载： 1sudo gem uninstall cocoapods 最新版本的 MacOS 可能会提示错误： 12ERROR: While executing gem ... (Gem::FilePermissionError) You don't have write permissions for the /usr/bin directory. 用以下命令可以解决： 1$ sudo gem uninstall -n /usr/local/bin cocoapods 然后查看本机安装的 cocoapods 相关的东西： 1$ gem list --local | grep cocoapods 一般会有如下显示： 12345678cocoapods-core (1.9.1, 1.8.4)cocoapods-deintegrate (1.0.4)cocoapods-downloader (1.2.2)cocoapods-plugins (1.0.0)cocoapods-search (1.0.0)cocoapods-stats (1.1.0)cocoapods-trunk (1.4.1)cocoapods-try (1.1.0) 然后使用命令逐个删除，比如： 1$ sudo gem uninstall cocoapods-core 或 1sudo gem uninstall -n /usr/local/bin cocoapods-core 卸载完成后重新安装即可。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 命名空间（namespace）的实现]]></title>
    <url>%2FSwift-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/// 实例对象的包装器public struct CCWrapper&lt;WrappedType&gt; &#123; /// 包装后的值 let wrappedValue: WrappedType init(wrappedValue: WrappedType) &#123; self.wrappedValue = wrappedValue &#125;&#125;/// 命名空间协议public protocol NameSpaceWrapper &#123; associatedtype WrapperType var cc: WrapperType &#123; get &#125; static var cc: WrapperType.Type &#123; get &#125;&#125;/// 命名空间协议默认实现public extension NameSpaceWrapper &#123; var cc: CCWrapper&lt;Self&gt; &#123; return CCWrapper(wrappedValue: self) &#125; static var cc: CCWrapper&lt;Self&gt;.Type &#123; return CCWrapper.self &#125;&#125;// 使用extension String: NameSpaceWrapper &#123;&#125;extension CCWrapper where WrappedType == String &#123; var hi: String &#123; return "Hi, I'm \(self.wrappedValue)" &#125; func sayHi(to person: String) &#123; print("\(self.wrappedValue) say hi to \(person)") &#125; static func hi(_ person: String) &#123; print("Hi, \(person)") &#125; &#125;print("Bruce".cc.hi)//Hi, I'm Bruce"Bruce".cc.sayHi(to: "Max")//Bruce say hi to MaxString.cc.hi("Jack")//Hi, Jack]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 关联类型（associatedtype）的使用]]></title>
    <url>%2FSwift-%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%EF%BC%88associatedtype%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[定义一个协议时，有时在协议定义里声明一个或多个关联类型是很有用的。关联类型给协议中用到的类型一个占位符名称。直到采纳协议时，才指定用于该关联类型的实际类型。关联类型通过 associatedtype 关键字指定。 举个例子： 12345678910111213141516171819202122232425protocol Eat &#123; associatedtype FoodType func eat(_ food: FoodType) -&gt; FoodType&#125;protocol Food &#123; var weight: CGFloat &#123; get set &#125; var desc: String &#123; get set &#125;&#125;struct Meat: Food &#123; var weight: CGFloat var desc: String&#125;struct Vegetable: Food &#123; var weight: CGFloat var desc: String&#125;struct Person&lt;T&gt;: Eat &#123; func eat(_ food: Food) -&gt; Food &#123; return food &#125;&#125; 我们定义了一个 Person，它每天都得吃饭，我们要求它遵循吃饭的协议 Eat，并实现了其中的 eat 方法。在协议 Eat 中我们声明了一个关联类型 FoodType。当 Person 的实例去调用 eat 方法时，我们使用泛型类型去指定之前的占位符 FoodType，那么我们就能清晰地知道 Person 的实例到底吃的是什么。 123456789let p = Person&lt;Food&gt;()let food1 = p.eat(Meat(weight: 1.2, desc: "meat"))print("eat \(food1.desc), weight \(food1.weight)")// eat meat, weight 1.2let food2 = p.eat(Vegetable(weight: 0.8, desc: "meat"))print("eat \(food2.desc), weight \(food2.weight)")// eat meat, weight 0.8]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 终端配置：fish + omf]]></title>
    <url>%2FMac-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9Afish-omf.html</url>
    <content type="text"><![CDATA[安装与配置 fish根据官网：https://fishshell.com/ 指引安装即可。 安装完之后，使用命令sudo vim /etc/shells打开配置文件，在文末加上/usr/local/bin/fish，保存退出。 运行chsh -s /usr/local/bin/fish命令使fish成为默认 shell。 使用fish_config配置主题，这里我选Solarized Dark。 安装 oh my fishcurl -L https://get.oh-my.fish | fish 安装之后，使用omf install eclm主题即可。 其它终端描述文件： https://github.com/altercation/solarized 下载后导入名为 Solarized Dark ansi 的配置文件。]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>终端</tag>
        <tag>fish</tag>
        <tag>omf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 查看某个文件的修改历史]]></title>
    <url>%2FGit-%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2.html</url>
    <content type="text"><![CDATA[查看某文件的修改记录git lg [filename] 查看某文件所有变更历史git lg -p [filename] 查看某文件在某次提交中的变更历史git show &lt;commit-id&gt; [filename] 恢复某个文件至某个版本git checkout &lt;commit-id&gt; [filename] lg = log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods 1.8.4 CDN 无法使用的问题]]></title>
    <url>%2FCocoapods-1-8-4-CDN-%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[好久没升级 Cocoapods 了，正好想升级一下，看到 官方文档 的视频演示，满心欢喜地去试用 CDN 。结果，心灰意冷了。 尝试了很多方法，仍然无法使用卖家秀一样的新特性。更可恨的是，我已经使用了 pod repo remove master 命令了。 经过几个小时的折腾后，放弃了。。。 看到 github 上有人提了同样的 issue ，给出的解决方案是不要使用 trunk，而是继续使用 master 库。希望这个 issue 能早日解决吧~ 不得已，删除了 trunk (pod repo remove trunk)，使用 镜像站点 重装了 cocoapods。 由于 Cocoapods 1.8.4 默认使用 CDN 来安装依赖，如果要用回原来的 master 库，需要指定 Podfile 的 source： 123456789101112131415# Uncomment the next line to define a global platform for your projectplatform :ios, '12.0'# source 'https://github.com/CocoaPods/Specs.git'source 'https://mirrors.tuna.tsinghua.edu.cn/git/CocoaPods/Specs.git'target 'test' do # Comment the next line if you don't want to use dynamic frameworks # pod 'ImagesView' pod 'Kingfisher' pod 'SnapKit' use_frameworks! # Pods for testend]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socks5 to http]]></title>
    <url>%2FSocks5-to-http.html</url>
    <content type="text"><![CDATA[安装和配置1brew install porivoxy 安装后，编辑 /usr/local/etc/privoxy/config，搜索socks5找到下面这句： 1#forward-socks5t / 127.0.0.1:9050 . 在下面添加： 1forward-socks5 / 127.0.0.1:port . port 为本机的 ss 代理的 socks5 端口。 配置文件中还有另外一句默认的： 1listen-address 127.0.0.1:8118 这表示 privacy 只监听本机的 8118 端。 开机启动1sudo brew services start privoxy 验证是否启动通过命令查看： 1netstat -an | grep 8118 使用Go 环境配置go get可能无法安装被墙的包，在完成以上步骤后，编辑~/.bash_profile文件，添加： 12export http_proxy=http://127.0.0.1:8118export https_proxy=http://127.0.0.1:8118 然后就可以成功的go get了。 VSCodeVSCode 安装插件的时候会失败，设置代理即可： 12"http.proxy": "http://127.0.0.1:8118","http.proxyStrictSSL": false]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>socks5, http, proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go Modules]]></title>
    <url>%2FGo-Modules.html</url>
    <content type="text"><![CDATA[简介Go modules是随着 Go 1.11 发布的新型的包管理工具，这也是官方推荐的。有了go mod，项目将不再依赖于GOPATH，你可以在任何路径下创建和管理项目，但是下载的依赖包仍然会存储在$GOPATH/pkg/mod路径。 使用配置在 Mac 下，编辑~/.bash_profile文件，写入export Go111MODULE=on 初始化 Modules在项目路径下，使用命令 go mod init &lt;packagename&gt;初始化 编辑 go.mod初始化的 go.mod 会显示如下内容： 1module packagename 添加依赖后： 123456module packagenamerequire ( github.com/test/A v1.2.3 github.com/test/B v1.2.3) 如果你不知道要依赖的版本，可以使用 latest代替版本号，在安装依赖时，go 会自动安装最新的版本。 go.mod 有四种指令： module：模块名称 require：依赖包列表以及版本 exclude：禁止依赖包列表（仅在当前模块为主模块时生效） replace：替换依赖包列表 （仅在当前模块为主模块时生效） 下载依赖包执行go get会下载指定的依赖包 其它命令： go get -u：更新至最新的版本 go get v -u=patch：只更新小的修订版本，例如从 v1.2.3 到 v1.2.4 go get github/com/test/test@v1.2.3：更新至指定版本 go mod vendorgo mod vendor将会复制 modules 到项目的 vendor 文件下，貌似只会复制代码中引用的库，而不是 go.mod 中定义的全部 modules go mod helpgo mod help会显示 go mod 命令帮助： 12345678download 下载依赖的module到本地cacheedit 编辑go.mod文件graph 打印模块依赖图init 再当前文件夹下初始化一个新的module, 创建go.mod文件tidy 增加丢失的module，去掉未用的modulevendor 将依赖复制到vendor下verify 校验依赖why 解释为什么需要依赖]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>modules</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go concurrency(并发)]]></title>
    <url>%2FGo-concurrency-%E5%B9%B6%E5%8F%91.html</url>
    <content type="text"><![CDATA[1. 简介goroutine 是 Go 中的并发执行单位，可以理解为“线程”，但它不是“线程”。生成一个 goroutine 非常简单，只需 go 一下就实现了。在同一个程序中所有的 goroutine 共享一个地址空间。goroutine 通过通信来共享内存，而不是共享内存来通信。 channel 是各个 goroutine 之间通信的管道，它是引用类型，可以使用 == 进行比较，如果引用了相同的数据结构，则结果为真。传数据用 channel &lt;- data，取数据用 &lt;- channel。多数情况下，它是阻塞同步的。channel 可以设置为单向或双向，也可以设置缓存大小，在未被填满前不会发生阻塞。 select 可处理一个或多个 channel 的发送与接收，同时有多个可用的 channel 时按随机顺序处理。 2. 基本使用样例 1 ： 1234567891011121314package mainimport ( "fmt")func main() &#123; ch := make(chan bool) go func() &#123; fmt.Println("Go go go!") ch &lt;- true &#125;() &lt;- ch&#125; go func() 启动了一个 goroutine，main 函数执行到 &lt;- ch 时会一直等待直到取得管道中的值，当打印出 “Go go go!“ 之后，才会传递值到管道中，这时候，程序才执行结束。这是一个简单的示例，我们不需要手动关闭管道，程序结束后占用的资源会自动释放。 样例 2 ： 12345678910111213141516171819package mainimport ( "fmt")func main() &#123; ch := make(chan bool) go func() &#123; fmt.Println("Go go go!") ch &lt;- true close(ch) &#125;() for v := range ch &#123; fmt.Println(v) // print "true" &#125;&#125; for range 会不断地迭代管道中的值，知道管道被关闭。如果我们删掉 close(ch) 这行代码，会导致死锁。 2. 设置缓存无缓存是同步阻塞的，有缓存是异步的。 样例 3 ： 1234567891011121314151617181920212223242526272829package mainimport ( "fmt" "runtime")func main() &#123; // 多核运行 runtime.GOMAXPROCS(runtime.NumCPU()) ch := make(chan bool, 10) for i := 0; i &lt; 10; i++ &#123; go Go(ch, i) &#125; for i := 0; i &lt; 10; i++ &#123; &lt;- ch &#125;&#125;func Go(ch chan bool, index int) &#123; a := 1 for i := 0; i &lt; 100000000; i++ &#123; a += 1 &#125; fmt.Println(a) ch &lt;- true&#125; 上例设置了一个缓存为 10 的管道，实现了多个 goroutine 的并发执行。除了 channel ，我们还可以用 WaitGroup 实现同样的效果，见样例 4 。 样例 4 ： 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "runtime" "sync")func main() &#123; // 多核运行 runtime.GOMAXPROCS(runtime.NumCPU()) wg := sync.WaitGroup&#123;&#125; wg.Add(10) for i := 0; i &lt; 10; i++ &#123; go Go(&amp;wg) &#125; wg.Wait()&#125;func Go(wg *sync.WaitGroup) &#123; a := 1 for i := 0; i &lt; 100000000; i++ &#123; a += 1 &#125; fmt.Println(a) wg.Done()&#125; 3. select 的用法select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个只能用于 channel 的通信操作，要么是发送要么是接收。 select 如果满足多个分支条件，则会随机执行一个 case 。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。 样例 5 : 123456789101112131415161718192021222324252627282930package mainimport ( "fmt" "time")func main() &#123; c1 := make(chan string) c2 := make(chan string) go func() &#123; time.Sleep(1 * time.Second) c1 &lt;- "one" &#125;() go func() &#123; time.Sleep(2 * time.Second) c1 &lt;- "two" &#125;() for i := 0; i &lt; 2; i++ &#123; select &#123; case msg1 := &lt;- c1: fmt.Println("received", msg1) case msg2 := &lt;- c2: fmt.Println("received", msg2) &#125; &#125;&#125; 样例 6 ： 12345678910111213141516171819202122232425262728package mainimport "fmt"func fibonacci(c, quit chan int) &#123; x, y := 0, 1 for &#123; select &#123; case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println("quit") return &#125; &#125;&#125;func main() &#123; c := make(chan int) quit := make(chan int) go func() &#123; for i := 0; i &lt; 10; i++ &#123; fmt.Println(&lt;-c) &#125; quit &lt;- 0 &#125;() fibonacci(c, quit)&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go reflection(反射)]]></title>
    <url>%2FGo-reflection-%E5%8F%8D%E5%B0%84.html</url>
    <content type="text"><![CDATA[1. 反射的基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package mainimport ( "fmt" "reflect")type User struct &#123; Id int Name string Age int&#125;func (u User) Hello() &#123; fmt.Println("Hello, world")&#125;func Info(o interface&#123;&#125;) &#123; t := reflect.TypeOf(o) fmt.Println("type:", t.Name()) // print "type: User" if k := t.Kind(); k != reflect.Struct &#123; fmt.Println("类型错误") return &#125; v := reflect.ValueOf(o) fmt.Println("fields:") for i := 0; i &lt; t.NumField(); i++ &#123; f := t.Field(i) val := v.Field(i).Interface() fmt.Printf("%6s: %v = %v\n", f.Name, f.Type, val) &#125; // print // fields: // Id: int = 1 // Name: string = ok // Age: int = 12 for i := 0; i &lt; t.NumMethod(); i++ &#123; m := t.Method(i) fmt.Printf("%6s: %v\n", m.Name, m.Type) &#125; // print "Hello: func(main.User)"&#125;func main() &#123; u := User&#123;1, "ok", 12&#125; Info(u)&#125; 注意：User 中的属性必须为大写程序才能正常运行，Go 是根据属性的首字母大小写来确定访问权限的，大写表示公有，小写表示私有。同理，方法签名 Hello 为小写，一样无法反射出对应的方法名。 2. 通过反射修改属性的值123456789101112131415161718192021222324252627282930313233343536373839package mainimport ( "fmt" "reflect")type User struct &#123; Id int Name string Age int&#125;func main() &#123; u := User&#123;1, "ok", 12&#125; Set(&amp;u) fmt.Println(u)&#125;func Set(o interface&#123;&#125;) &#123; v := reflect.ValueOf(o) if v.Kind() == reflect.Ptr &amp;&amp; v.Elem().CanSet() &#123; v = v.Elem() &#125; else &#123; return &#125; f := v.FieldByName("Name") if !f.IsValid() &#123; fmt.Println("Not found") return &#125; if f.Kind() == reflect.String &#123; f.SetString("BYE") &#125;&#125; 3. 通过反射动态调用方法1234567891011121314151617181920212223242526package mainimport ( "fmt" "reflect")type User struct &#123; Id int Name string Age int&#125;func (u User) Hello(name string) &#123; fmt.Println("Hello", name, ", my name is", u.Name)&#125;func main() &#123; u := User&#123;1, "ok", 12&#125; v := reflect.ValueOf(u) mv := v.MethodByName("Hello") args := []reflect.Value&#123;reflect.ValueOf("john")&#125; mv.Call(args) //print "Hello john , my name is ok"&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go interface(接口)]]></title>
    <url>%2FGo-interface-%E6%8E%A5%E5%8F%A3.html</url>
    <content type="text"><![CDATA[1. 概念接口是一个或多个方法签名的集合，只有方法声明，没有实现。 只要某个类型拥有该接口的所有方法签名，即算实现了该接口，无需显式声明了哪个接口，这称为 Structural Typing 。 接口也是一种类型，它是一种抽象类型，空接口 interface {} 类似于 NSObject 这样的万物之主，虽然 Go 中是没有 class 的概念，但 interface 实现了继承多态的效果。 2. 使用 样例1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package mainimport ( "fmt")type USB interface &#123; Name() string Connecter // 嵌入&#125;type Connecter interface &#123; Connect()&#125;type PhoneConnecter struct &#123; name string&#125;func (pc PhoneConnecter) Name() string &#123; return pc.name&#125;func (pc PhoneConnecter) Connect() &#123; fmt.Println("Connect:", pc.name) // Disconnected: PhoneConnecter&#125;func Disconnect(usb interface&#123;&#125;) &#123; // ok pattern 进行类型判断 //if pc, ok := usb.(PhoneConnecter); ok &#123; // fmt.Println("Disconnected:", pc.name) // return //&#125; //fmt.Println("Disconnected.") // type switch 进行类型判断 switch v := usb.(type) &#123; case PhoneConnecter: fmt.Println("Disconnected:", v.name) // print "Connect: PhoneConnecter" default: fmt.Println("Unknown Device") &#125;&#125;func main() &#123; a := PhoneConnecter&#123;"PhoneConnecter"&#125; a.Connect() Disconnect(a)&#125; 样例2： 123456789101112131415161718192021222324252627282930313233package mainimport ( "fmt")type square struct &#123; r int &#125;type circle struct &#123; r int &#125;func (s square) area() int &#123; return s.r * s.r &#125;func (c circle) area() int &#123; return c.r * 3 &#125;func main() &#123; s := square&#123;2&#125; c := circle&#123;3&#125; a := [2]interface&#123;&#125;&#123;s, c&#125; fmt.Println(s, c, a) // print "&#123;2&#125; &#123;3&#125; [&#123;2&#125; &#123;3&#125;]" sum := 0 for _, t := range a &#123; switch v := t.(type) &#123; case square: sum += v.area() case circle: sum += v.area() &#125; &#125; fmt.Println(sum) // print "13"&#125;]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>interface</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 运算符的重载和自定义]]></title>
    <url>%2FSwift-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89.html</url>
    <content type="text"><![CDATA[1. 运算符的重载1.1 基本运算符的重载1234567891011func * (lhs: String, rhs: Int) -&gt; String &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125;let t = "abc"print(t * 3)// print "abcabcabc" 如上所示，我们重载了运算符 * 。再看看另一个例子： 123struct Vector2D &#123; var x = 0.0, y = 0.0&#125; 我们定义了如上的结构体，如果想把两个 Vector2D 类型的实例相加，编译器是会报错的。如果我们重载操作符 + ，就可以实现相加： 1234567func + (lhs: Vector2D, rhs: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: lhs.x + lhs.x, y: rhs.y + rhs.y)&#125;let first = Vector2D(x: 1.0, y: 2.0)let second = Vector2D(x: 3.0, y: 4.0)print(first + second)// print "Vector2D(x: 4.0, y: 6.0)" 1.2 泛型运算符 1234567func * &lt;T&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125; 按照常理，我们会将第一个例子做如上改写，但是编译器会提示 Binary operator ‘+=’ cannot be applied to two ‘T’ operands ，这是因为 T 类型并不能直接使用加法符合运算符，我们可以通过让 T 类型遵循实现了加法功能的协议来解决这个问题，改写后的代码如下： 1234567891011121314151617protocol Type &#123; static func + (lhs: Self, rhs: Self) -&gt; Self static func += (lhs: inout Self, rhs: Self)&#125;extension String: Type &#123;&#125;extension Int: Type &#123;&#125;extension CGFloat: Type &#123;&#125;func * &lt;T: Type&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123;// result = result + lhs result += lhs &#125; return result&#125; 2. 运算符的自定义先介绍 Swift 中的三个关键字： prefix：前缀运算符，比如 ++i 中的 ++ postfix：后缀运算符，比如 i++ 中的 ++ infix：中缀运算符，比如 a + b 中的 + 这里仅以 infix 为例示范其用法，现在我们自定义一个运算符 ** 和符合运算符 **= ，实现第一个例子的功能。 12345678910111213141516171819202122infix operator **func ** &lt;T: Type&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125;infix operator **=func **= &lt;T: Type&gt; (lhs: inout T, rhs: Int) &#123; lhs = lhs ** rhs&#125;let t = "abc"let s = t ** 3print(s)// print "abcabcabc"var u = "abc"u **= 3print(u)// print "abcabcabc" 至此，运算符的重载和自定义的基本功能就介绍完毕了。当然，自定义运算符同样是可以定义优先级和结合性的，这里不做过多讲解，有兴趣的朋友可以自行查阅资料。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods 创建公有库命令]]></title>
    <url>%2FCocoaPods-%E5%88%9B%E5%BB%BA%E5%85%AC%E6%9C%89%E5%BA%93%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[1. 注册 CocoaPods 账号 通过终端运行一下命令注册账号： 1pod trunk register 邮箱地址 用户名 --verbose 然后去邮箱验证一下邮箱地址 注册成功后，可以通过 pod trunk me 查看账号信息和发布过的库 2. 公有库的内容构成2.1 共享的文件夹这里存放的是需要共享的内容，也就是别人通过 pod 安装得到的源码，.podspec 文件中的 source_files 指定的就是这个共享文件夹的路径 2.2 LICENSE 文件如果你的公有库是放在 GitHub 上托管，可以将工程上传以后，直接在网页给工程添加 LICENSE 文件，GitHub 会自动给出开源协议的可选项，一般选择 MIT 2.3 .podspec本库的描述文件，需要提交给 CocoaPods 可以通过一下命令创建 .podspec： 1pod spec create 库名 CocoaPods 默认会生成一个 .podspec 的模版文件，更改相应的信息即可，关于 .podspec 的各个参数解释，这里不再赘述，有需要的自行上网查找 3. 发布3.1 错误排查pod lib lint 命令可以验证本地的 .podspec 文件是否合法，如果与错误，会给出相应的提示，根据提示解决错误 3.2 将工程提交到 GitHub3.3 打上 tag12git tag 1.0.0git push --tags 注意： .podspec 中的 s.version 的值要和 tag 保持一致 3.4 发布pod trunk push 库名.podspec 发布成功后，pod search 库名 应该就可以搜到自己的库了 如果搜索不到，试试运行如下命令: 12pod setup rm ~/Library/Caches/CocoaPods/search_index.json 然后执行 pod search 库名 4. 更新更新代码，更改 .podspec 文件的 s.version ，打上 tag ，推送最新的代码到远端服务器，执行 pod lib lint 和 pod trunk push 库名.podspec]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>cocoapods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 编译器提示 TODO 和 FIXME]]></title>
    <url>%2FSwift-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%90%E7%A4%BA-TODO-%E5%92%8C-FIXME.html</url>
    <content type="text"><![CDATA[Build Phases，点击 +，添加 New Run Script Phase，添加如下内容： 123TAGS="TODO:|FIXME:"echo "searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;"find "$&#123;SRCROOT&#125;" \( -name "*.swift" \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/" 在代码处添加如下标记：12// TODO: something to do// FIXME: fix bug 编译器会自动给出相应的警告，并且可以快速定位到相应的代码处。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
        <tag>TODO</tag>
        <tag>FIXME</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles 显示乱码问题解决方案]]></title>
    <url>%2FCharles-%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[Charles 版本：4.2 安装 Mac 的 cer 证书后，点击 Charles 的 proxy - SSL Proxying Settings - SSL Proxying - Add，Host 填写 * ，Port 填写 443 安装手机上的 CA 证书后，点击 通用 - 关于本机 - 证书信任设置 ，信任对应的证书 Charles.app 右键显示包内容，打开 info.plist ，添加 vmoption 字段，设置对应的值为 -Dfile.encoding=UTF-8]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift编程风格指南]]></title>
    <url>%2FSwift%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[1. 命名使用驼峰式命名法，类、结构体、枚举、协议的首字母应该大写，而方法、变量名首字母则小写。 123456private let maximumWidgetCount = 100class WidgetContainer &#123; var widgetButton: UIButton let widgetHeightPercentage = 0.85&#125; 1.1 枚举对于枚举值，应该使用首字母小写的驼峰命名法： 123456enum Shape &#123; case Rectangle case Square case Triangle case Circle&#125; 1.2 类名前缀(Class Prefix)Swift 类型自动为模块名设置了命名空间，所以没有必要为 Swift 的类型添加类似 KS 这样的前缀了。如果两个来自不同模块的命名冲突了了，你可以在它们前面添加模块名来避免冲突。 123import SomeModulelet myClass = MyModule.UsefulClass() 1.3 泛型泛型名应该有较好的阅读性，用首字母大写的驼峰式命名。当一个类型没有有意义的关系和角色，使用传统的 T、U、V 来替代。 123struct Stack&lt;Element&gt; &#123; ... &#125;func writeTo&lt;Target: OutputStream&gt;(inout target: Target)func max&lt;T: Comparable&gt;(x: T, _ y: T) -&gt; T 1.4 语言使用美式英语，更符合苹果的 API 标准。 2. 代码结构2.1 代码分块使用// MARK: -对代码进行分块组织，代码的组织顺序从整体上尽量符合我们的认知顺序。 2.2 无用代码对于无用的代码，都应该被删掉。 2.3 最小引用只import你需要的模块。比如，如果引用Foundation以及足够，就不要再引用UIKit了。 3. 类和结构体3.1 选择哪个？结构体是值类型，类是引用类型。 按照通用的准则，当符合一条或多条以下条件时，请考虑构建结构体： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 3.2 Self 的使用为了保持简洁，避免使用 self 关键词，Swift 不需要使用 self 来访问对象属性和调用对象方法。 在以下情况中需要使用self： 在构造器中，为了区分传入的参数和属性 在闭包中访问属性 123456789101112class BoardLocation &#123; let row: Int, column: Int init(row: Int, column: Int) &#123; self.row = row self.column = column let closure = &#123; println(self.row) &#125; &#125;&#125; 3.3 计算属性如果一个计算属性是只读的，忽略 get 语句。只有在需要定义 set 语句的时候，才提供 get 语句。123var diameter: Double &#123; return radius * 2&#125; 3.4 Final如果类不会被继承，那么用关键词 final 标记。 123456final class Box&lt;T&gt; &#123; let value: T init(_ value: T) &#123; self.value = value &#125;&#125; 4. 协议遵守当我们对一个类添加协议时，推荐使用一个单独的类扩展来实现协议的方法。这可以保持协议相关的方法聚合在一起，同时也可以简单的标识出一个协议对应类中需要实现哪些对应的方法。 推荐做法：12345678910111213class MyViewcontroller: UIViewController &#123; // class stuff here&#125;// MARK: - UITableViewDataSourceextension MyViewcontroller: UITableViewDataSource &#123; // table view data source methods&#125;// MARK: - UIScrollViewDelegateextension MyViewcontroller: UIScrollViewDelegate &#123; // scroll view delegate methods&#125; 不推荐做法：123class MyViewcontroller: UIViewController, UITableViewDataSource, UIScrollViewDelegate &#123; // all methods&#125; 5. 函数声明保证短的函数定义在同一行中，并且包含左大括号： 123func reticulateSplines(spline: [Double]) -&gt; Bool &#123; // reticulate code goes here&#125; 在一个长的函数定义时，在适当的地方进行换行，同时在下一行中添加一个额外的缩进： 1234func reticulateSplines(spline: [Double], adjustmentFactor: Double, translateConstant: Int, comment: String) -&gt; Bool &#123; // reticulate code goes here&#125; 6. 闭包表达式详细参考：Swift 中的闭包 7. 类型尽可能使用 Swift 原生类型。 7.1 常量常量定义使用 let 关键字，变量定义使用 var 关键字，如果变量的值不需要改变，请尽量使用 let 关键字。提示：一个好的技巧是，使用 let 定义任何东西，只有在编译器告诉我们值需要改变的时候才改成 var 定义。 7.2 可选类型当一个变量或函数返回值可以为 nil 时，用 ? 将其声明为可选类型。 当确定变量在使用前被初始化，使用 ! 来解包。 必要时，使用可选值链： 1self.textContainer?.textLabel?.setNeedsDisplay() 对于需要将可选值解包，并多出使用的情况，使用可选值绑定： 123if let textContainer = self.textContainer &#123; // do many things with textContainer&#125; 当我们命名一个可选变量和属性时，避免使用诸如 optionalString 和 maybeView 这样的命名，因为可选值的表达已经在类型定义中了。 在可选值绑定中，直接映射原始的命名比使用诸如 unwrappedView 和 actualLabel 要好。 推荐做法： 1234567var subview: UIView?var volume: Double?// later on...if let subview = subview, volume = volume &#123; // do something with unwrapped subview and volume&#125; 7.3 语法糖推荐使用简短的类型声明。 推荐做法： 123var deviceModels: [String]var employees: [Int: String]var faxNumber: Int? 不推荐做法： 123var deviceModels: Array&lt;String&gt;var employees: Dictionary&lt;Int, String&gt;var faxNumber: Optional&lt;Int&gt; 8. 控制流使用循环时，推荐用 for-in 表达式，而不是 for-condition-increment 表达式。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>swift</tag>
        <tag>编程风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的一些关键字]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[open：可以在任何地方访问、继承和重写 public：可以在任何地方被访问，在其他模块不能被继承和重写 internal：默认访问级别，在整个模块内都可以被访问 fileprivate：可以在同一个文件内被访问、继承和重写 private：只能在本类访问和使用，不包括扩展类 fallthrough ：Swift 中的 switch 语句可以省略 break，满足条件直接跳出循环。fallthrough 则具有贯穿作用，会继续执行后续的 case，直到碰到 break 或 default 才跳出循环。 123456789switch integerToDescribe &#123; case 1, 3, 5, 7, 11, 13, 17, 19: description += " a prime number, and also"; fallthrough // 执行到此并不跳出循环,而是继续执行case5case 5: description += " an integer" // 执行到这一步,跳出循环default : description += " finished" &#125; where：用于条件判断 12345678let yetAnotherPoint = (1, -1) switch yetAnotherPoint &#123; case let (x, y) where x == y: println("(\\(x), \\(y)) is on the line x == y") case let (x, y) where x == -y: println("(\\(x), \\(y)) is on the line x == -y") case let (x, y): println("(\\(x), \\(y)) is just some arbitrary point") inout：将值类型参数以引用方式传递 123456var x = 10func add(x: inout Int, y: Int) &#123; x += y&#125;add(x: &amp;x, y: 5)print(x) // x = 15 is &amp; as：is 用于类型判断，as 用于强制转换 12345678for view : AnyObject in self.view.subviews &#123; if view is UIButton &#123; let btn = view as UIButton; println(btn) &#125; &#125; as 使用场合： 向上转型： 1234class Animal &#123;&#125;class Cat: Animal &#123;&#125;let cat = Cat()let animal = cat as Animal 数值类型转换： 1234let num1 = 42 as CGFloatlet num2 = 42 as Intlet num3 = 42.5 as Intlet num4 = (42 / 2) as Double switch 语句 1234567switch animal &#123; case let cat as Cat: print("如果是Cat类型对象，则做相应处理") case let dog as Dog: print("如果是Dog类型对象，则做相应处理") default: break&#125; as! 用于强制转换，转换失败会导致程序崩溃，而 as? 转换失败时会返回一个 nil 对象。 guard：与 if 相反，当不满足条件时执行后面的语句。 123456789func test(input: Int?) &#123; guard let _ = input else &#123; print("Input cannot be nil") return &#125;&#125;test(input: nil)// print "Input cannot be nil" defer：该关键字包裹的一段代码会延迟执行，当前作用域结束的时候会被调用。当同一个作用域指定多个 defer 代码块，在当前作用域结束时，先定义的后执行，后定义的先执行。 static：和 class 关键词一样，都用来生成类方法，不同的是，class 修饰的方法可以被重写，而 static 不行。 mutating ：当需要在方法中修改 struct、enum 中的成员值时，用 mutating 修饰对应的方法。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的闭包]]></title>
    <url>%2FSwift%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85.html</url>
    <content type="text"><![CDATA[1. 闭包表达式语法123&#123; (parameters) -&gt; returnType in statements&#125; 下面是利用闭包对数组进行反向排序的一个例子： 123456let names = ["Chris", "Alex", "Ewa", "Barry", "David"]let reservedNames = names.sorted &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;print(reservedNames)// print "["Ewa", "David", "Chris", "Barry", "Alex"]" 2. 根据上下文推断类型上文中的参数类型和返回类型都可以被正确推断，因此可以简写为如下形式： 1let reservedNames = names.sorted &#123; s1, s2 in return s1 &gt; s2 &#125; 3. 单表达式闭包返回单行表达式闭包可以省略关键字 return ，上例可以进一步简写为： 1let reservedNames = names.sorted &#123; s1, s2 in s1 &gt; s2 &#125; 4. 参数名称缩写Swift 自动为内联闭包提供参数名称缩写功能，可以直接通过 $0， $1， $2 来顺序调用闭包的参数，以此类推。 如果使用缩写的参数名称，可以在闭包定义中省略参数列表，Swift 会自动推断参数类型。in 关键字也可以被省略，因此上例的极简写法如下： 1let reservedNames = names.sorted &#123; $0 &gt; $1 &#125; 5. 尾随闭包如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，可以使用尾随闭包来增强函数的可读性。 尾随闭包是一个书写在函数括号之后的闭包表达式，函数支持将其作为最后一个函数调用。在使用尾随闭包时，不用写出它的参数标签。 1let reservedNames = names.sorted() &#123; $0 &gt; $1 &#125; 当闭包表达式是函数或方法的唯一参数时，可以省略 () ： 1let reservedNames = names.sorted &#123; $0 &gt; $1 &#125; 6. 值捕获12345678910111213func makeIncremeter(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incremeter() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incremeter&#125;let incrementByTen = makeIncremeter(forIncrement: 10)incrementByTen() // return 10incrementByTen() // return 20incrementByTen() // return 30 incrementer() 是一个嵌套函数，它从外围函数捕获了 runningTotal 和 amount 变量的引用。捕获引用保证了 runningTotal 和 amount 变量在调用完 makeIncrementer 后不会消失，并且保证了在下一次执行 incrementer函数时， runnningTotal 依旧存在。 如果你创建了另一个 incrementer ，它会有属于自己的引用，指向一个全新、独立的 runningTotal 变量： 123let incrementByFive = makeIncremeter(forIncrement: 5)incrementByFive() // return 5incrementByFive() // return 10 再看看下面的代码： 12let alsoIncrementerByTen = incrementByTenalsoIncrementerByTen() // return 40 这说明 alsoIncrementerByTen 和 incrementerByTen 指向的是同一个闭包，说明闭包时引用类型。 7. 逃逸闭包当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸，我们在参数名之前标注 @escaping 来表明这个闭包时允许“逃逸”出这个函数的。 一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。下面这个例子中的闭包会在函数返回之后才被调用： 1234var completionHandles: [() -&gt; Void] = []func someFunctionWithEscapinClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandles.append(completionHandler)&#125; 将一个闭包标记为 escaping 意味着你必须在闭包中显式地引用 self 。而非逃逸闭包，可以隐式地引用 self 。 12345678910111213141516171819202122func someFunctionWithNonescapingClosure(closure: () -&gt; Void) &#123; closure()&#125;class SomeClass &#123; var x = 10 func doSomething() &#123; someFunctionWithEscapinClosure &#123; self.x = 100 &#125; someFunctionWithNonescapingClosure &#123; x = 200 &#125; &#125;&#125;let instance = SomeClass()instance.doSomething()print(instance.x) // print "200"completionHandles.first?()print(instance.x) // print "100" 8. 自动闭包自动闭包是一种自动创建的闭包，用于包装传递给函数作为参数的表达式。它不接受任何参数，当它被调用时，会返回被包装在其中的表达式的值。自动闭包只有被调用的时候，代码才会延迟执行。 12345678var arr = [1, 2, 3, 4, 5]print(arr.count) // print "5"let cl = &#123; arr.remove(at: 0) &#125;print(arr.count) // print "5" , 说明闭包并没有执行print("Now remove \(cl())") // print "Now remove 1", 此时调用了自动闭包print(arr.count) // print "4" 注：cl 的类型不是 Int ， 而是 () -&gt; Int ，一个没有参数且返回值为 Int 的函数。 将闭包作为参数传递给函数时，同样能获得延时求值行为。 12345678func cl(element removeElement: () -&gt; Int) &#123; print("Now remove \(removeElement())")&#125;cl &#123; () -&gt; Int in arr.remove(at: 0)&#125;// print "Now remove 2" 上面的 cl 函数接受一个返回移除元素的显式的闭包。下面的例子完成了相同的操作，不过它并没有接受一个显式的闭包，而是通过将参数标记为 @autoclosure 来接收一个自动闭包。现在你可以将该函数当做接受 Int 类型参数（而非闭包）的函数来调用，removeElement 参数将自动转化为一个闭包。 123456func cl2(remove removeElement: @autoclosure () -&gt; Int) &#123; print("Now remove \(removeElement())")&#125;cl2(remove: arr.remove(at: 0))// print "Now remove 3" 如果你想让一个自动闭包可以“逃逸”， 则应该同时使用 @autoclosure 和 escaping 关键字。]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS疑难杂症]]></title>
    <url>%2FiOS%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87.html</url>
    <content type="text"><![CDATA[1. The file “Info.plist” couldn’t be opened because there is no such file.原因： Info.plist 文件找不到了，可能是被删除了或是被移动了。解决方法：按照下面的顺序找到 info.plist File ，修改成 info.plist 的实际路径即可。1targets --&gt; Build Settings --&gt;搜索 Info.plist --&gt; Packaging -&gt; info.plist File 2. 只要有改动 Xcode 不停地 building选择任意一个 Storyboard ，Editor -&gt; Automatically Refresh Views， 关闭这个选项即可。]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人与人之间的关系]]></title>
    <url>%2F%E4%BA%BA%E4%B8%8E%E4%BA%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.html</url>
    <content type="text"><![CDATA[微博上刷到这几张图片，对我的触动很大，激发出我很强的认同感。这可能是我整个荒废的十一假期得到的唯一且最大的思想收获了：） 随着年纪愈长，我的思想观念也开始趋于清晰和稳定。李安对人际关系的理解，远远超出了当代人的水平，也许人类还需要几百年的发展才能达到他所描述的人际关系。 回望过去的自己，真的是幼稚的可怕。现在的我，仍然需要被雕刻。 我们每个人都是独立的个体，不可能有完全一样的价值观。能气味相投的人，价值观上必然存在相互之间的认同感。面对形形色色的人，我不喜欢用“善变”来处理和他们的关系。我努力寻找自我，一直希望找到一种普适的方法。前段时间，我希望自己做个“真实而温暖”的人。这个定义应该需要优化一下，如果我喜欢作恶，也许也是真实的一面，但那样不好，或许善良比真实的涵义更美好，它应该是涵盖了真实的全部成分。所以，我需要努力去做一个“善良而温暖”的人。 受李安的启发，最后结语，我觉得人和人之间比较理想的状态是：爱和尊重。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>李安</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纪录片《从秦始皇到汉武帝》]]></title>
    <url>%2F%E7%BA%AA%E5%BD%95%E7%89%87%E3%80%8A%E4%BB%8E%E7%A7%A6%E5%A7%8B%E7%9A%87%E5%88%B0%E6%B1%89%E6%AD%A6%E5%B8%9D%E3%80%8B.html</url>
    <content type="text"><![CDATA[不知道为啥油管会推荐这部片子给我，难道因为我之前看了《大军师司马懿》？顺便说一句，YouTube是当今世界最懂人的视频网站，它背后的算法总能把你喜欢的视频呈现给你，而且让你沉迷于其中一个接一个的推荐视频。 看到这部片子豆瓣评分8.4分，点进去看，一开始以为是个电视剧，没想到是部颇为值得一看的纪录片。 读书的时候，政史地一直是我的薄弱项。至今我对中国的历史年表还搞不清顺序，我是抱着补充历史知识的念头去看的，也确实收获不少。 之前，秦始皇在我的印象中就只有“始皇帝”和“暴君”两个标签。现在不是这样了，嬴政在我心里成了一个伟大的历史人物。 战国时代，嬴政就能有一统天下的远见和气魄而且最终灭掉了六国，他已经开创了一个时代，足以永远地烙在历史的丰碑上。嬴政称帝后，并没有满足于现状，而是进行了大刀阔斧地改革，目的只有一个，就是不仅仅要在地域上一统天下，更要一统人心。然而天下人能懂他的太少了，社会一直处于动荡之中，他至死也没能收服天下人心。早期的秦始皇极富远见和包容之心，却一直活在世人的误解之中，�最终导致他出现“暴虐”的倾向。 郭沫若说过“百代皆行秦政”，事实确实如此，直至今日，中央集权制仍然是我国的政权制度。虽然秦朝只有十多年历史，嬴政的思想却影响后世千年直至今日。 继承了秦始皇的理想的并不是他的后人，而是他的崇拜者庶民刘邦。可惜，巍峨壮阔的咸阳城，毁在了霸王项羽手上。项羽想恢复封建秩序，而刘邦看到了秦始皇中央集权制度制度的意义，刘邦才是顺应时代发展的弄潮儿。 我们现在看历史，就像开了上帝视角。历史可以作为一面镜子，避免我们踩同样的坑。然而要顺应时代的发展，开创一个新的局面，仅仅以史为镜是不够的，必须要有超时代的眼界。后人不过是在实现秦始皇的理想帝国罢了，秦始皇是当之无愧的千古一帝。 秦始皇很早就意识到帝国统一的根本是文化的统一，然而他采取了焚书的极端方式，这样急功近利的做法为秦帝国的覆灭埋下了种子。 没想到刘氏的继承人汉武帝是用儒家思想来凝聚人心的，通过文化手段把整个社会由无为转变为进取有为，最终灭掉了匈奴，实现的华夏帝国的大一统。 看到最后一集时，油管又给我推荐了《东方帝王谷》（豆瓣9.3分）和《复活的军团》（豆瓣8.9分），时间有限就没有继续看了。这些都是陕西省的文化输出啊，我现在感觉关中地区随便找个地方挖一铲子，都可能是个帝王陵，正所谓“南方的才子北方的将，陕西的黄土埋皇上”。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>纪录片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中文显示乱码的解决方案（Mac）]]></title>
    <url>%2FGit%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B9%B1%E7%A0%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88Mac%EF%BC%89.html</url>
    <content type="text"><![CDATA[终端运行以下命令即可： 1git config --global core.quotepath false]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《奔跑吧，奥沙利文》]]></title>
    <url>%2F%E8%AF%BB%E3%80%8A%E5%A5%94%E8%B7%91%E5%90%A7%EF%BC%8C%E5%A5%A5%E6%B2%99%E5%88%A9%E6%96%87%E3%80%8B.html</url>
    <content type="text"><![CDATA[只用了三个晚上，就读完了这本书，这应该是我有史以来最快的读书速度了。因为他是我的偶像，我为之着迷。 “跑步是我的信仰体系，是我赖以保持内心平静的途径。跑步的过程身体是痛苦难耐的，但跑步又是让我达到精神高度的最佳途径。”这段话出现在书的开头，我认为是全书精华所在。当我读到这里的时候，引起了我的一些共鸣。 国人大多是不爱运动的，我从小也没什么运动天赋，也从未痴迷于某项运动。因我从小体弱多病，父亲为我常年寻医问药，后来才从一个瘦猴变成了一个微胖的小伙。高中开始失眠抑郁，直至今日亦是如此。所以一直以来我从未真正地感受过健康的状态，我最好的状态大概是我大学末期去健身房锻炼的某个学期。我并不以肌肉男为目的，而是刷脂减肥，果然后来瘦了，整个人的精神状态提升了不少，连颜值都涨了不少。这使我深信，运动可以改变一个人，它可以让你变得更好。 我天性自由散漫，很难在一件事情上常年坚持。自从那个健身的学期之后，运动成了间歇性的爱好。运动尝到的甜头还是输给了自我放逐，我从来都没有达到过满意的身材。我不是那种凡是去做就一定要做第一的人，总的来说，我思想算是比较中庸，自然就会显得很平庸。我想我应该改变一些，让自己变得更追求完美可能会更好。 从8月初到现在9月末，我不知道最近到底过得什么日子。沉迷游戏，逃避现实和孤独，没有任何运动，睡眠严重不足，工作和学习效率低下，恶性循环。。。然而心底却一直有个声音告诉自己不能放弃治疗，需要做出改变。 我试图从书中去汲取力量，确实效果不错。读完了《奔跑吧，奥沙利文》，给了我很多启发和动力，我也对火老师有了更多的了解。他就是那么个真性情的人，我想我应该活得简单点，真实而温暖足矣。 奔跑吧，去寻找真实的自我！]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>奥沙利文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS小贴士]]></title>
    <url>%2FiOS%E5%B0%8F%E8%B4%B4%E5%A3%AB.html</url>
    <content type="text"><![CDATA[隐藏导航栏横线1234567891011121314151617181920212223242526272829303132333435363738@interface ViewController ()@property (nonatomic, strong) UIImageView *navBarHairlineImageView;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; self.navBarHairlineImageView = [self findHairlineImageViewUnder:self.navigationController.navigationBar];&#125;- (UIImageView *)findHairlineImageViewUnder:(UIView *)view &#123; if ([view isKindOfClass:UIImageView.class] &amp;&amp; view.bounds.size.height &lt;= 1.0) &#123; return (UIImageView *)view; &#125; for (UIView *subview in view.subviews) &#123; UIImageView *imageView = [self findHairlineImageViewUnder:subview]; if (imageView) &#123; return imageView; &#125; &#125; return nil;&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; self.navBarHairlineImageView.hidden = YES;&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; self.navBarHairlineImageView.hidden = NO;&#125; Storyboard勾选Hide-Bottom-Bar-on-Push带来黑影问题去掉”Hide Bottom Bar on Push”前面的勾，在相应的控制器中使用代码来实现tabbar的显示和隐藏，即分别在viewWillAppear和viewWillDisappear方法中实现所需要的效果。 判定viewWillDisappear是push还是pop1234567if ([self.navigationController.viewControllers indexOfObject:self] == NSNotFound) &#123; //pop [self.navigationController setNavigationBarHidden:YES animated:YES]&#125; else &#123; //push [self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 自定义导航栏返回箭头导致返回手势失效在自定义导航控制器viewDidLoad方法中加入如下代码：1self.interactivePopGestureRecognizer.delegate = (id)self; 自定义导航栏为渐变色在自定义导航控制器中设置：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma mark - life cycle- (void)viewDidLoad &#123; [super viewDidLoad]; [self setBarBackgroundColor];&#125;#pragma mark - private method- (void)setBarBackgroundColor &#123; for (UIView *view in self.navigationBar.subviews) &#123; if ([view isKindOfClass:NSClassFromString(@"_UIBarBackground")] || [view isKindOfClass:NSClassFromString(@"_UINavigationBarBackground")]) &#123; NSString *phoneVersion = [[UIDevice currentDevice] systemVersion]; UIView *iView = nil; if (phoneVersion.floatValue &lt; 10.0) &#123; iView = view; &#125; else &#123; for (UIView *subView in view.subviews) &#123; if ([subView isKindOfClass:[UIVisualEffectView class]]) &#123; iView = subView; &#125; &#125; &#125; CRLog(@"it is"); CGRect frame = iView.frame; CRLog(@"%@", NSStringFromCGRect(frame)); UIView *alphaView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, frame.size.width, frame.size.height + 20)]; alphaView.backgroundColor = [UIColor whiteColor]; alphaView.userInteractionEnabled = NO; [iView addSubview:alphaView]; [self setShadeColorWithView:alphaView]; &#125; &#125;&#125;- (void)setShadeColorWithView:(UIView *)view &#123; CAGradientLayer *gradientLayer = [CAGradientLayer layer]; gradientLayer.startPoint = CGPointMake(0, .5); gradientLayer.endPoint = CGPointMake(1, .5); gradientLayer.colors = @[(id)RGBA(76, 202, 90, 1).CGColor,(id)RGBA(39, 182, 112, 1).CGColor]; gradientLayer.frame = view.bounds; [view.layer addSublayer:gradientLayer];&#125; 全局设置导航控制器返回按钮在自定义导航控制器中做如下拦截处理：123456789101112- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123; UIImage *image = [[UIImage imageNamed:@"backButton_background"] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]; viewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithImage:image style:UIBarButtonItemStyleDone target:self action:@selector(back)]; [super pushViewController:viewController animated:animated];&#125;#pragma mark - back- (void)back &#123; [self popViewControllerAnimated:YES];&#125; 通过Scheme区分管理Debug和Release环境 1、 新建两个Scheme，分别为 projectName-Debug 和 projectName-Release ，编辑对应的Scheme，将 Build Configuration 分别改为 Debug 和 Release。 2、 在PCH文件中添加如下宏定义：12345#ifdef DEBUG#define kServer @"http://192.168.0.1:8080"#else#define kServer @"http://xxoo.com"#endif Sample code:demo/Debug&amp;Release-Demo PCH常用宏定义12345678910111213141516171819202122#define RGBA(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:a]#define KSColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]#define KSRandomColor CRColor(arc4random_uniform(256), arc4random_uniform(256), arc4random_uniform(256))#define kCellSeparateColor RGBA(200, 199, 204, 1)#ifdef DEBUG#define KSLog(...) NSLog(@"%s %d \n %@ \n\n",__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])#define kServer @"http://192.168.1.xx"#else#define KSLog(...) #define kServer @"http://xx.com"#endif#define kIsPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)#define kFontSize12 kIsPad ? [UIFont systemFontOfSize:14] : [UIFont systemFontOfSize:12]#define kFontSize14 kIsPad ? [UIFont systemFontOfSize:16] : [UIFont systemFontOfSize:14]#define kFontSize16 kIsPad ? [UIFont systemFontOfSize:18] : [UIFont systemFontOfSize:16]#define kFontSize18 kIsPad ? [UIFont systemFontOfSize:20] : [UIFont systemFontOfSize:18]#define kLastWindow [[UIApplication sharedApplication].windows lastObject]]]></content>
      <categories>
        <category>ios</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>小贴士</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 工程 Git配置参考]]></title>
    <url>%2FXcode-%E5%B7%A5%E7%A8%8B-Git%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83.html</url>
    <content type="text"><![CDATA[全局配置1、根目录下touch .gitignore_global2、在创建的文件中写入如下内容：123456789# .gitignore_global.DS_Store.DS_Store?*.DS_Store*/.DS_Store*/.xcuserstate*.xcuserstate 3、打开根目录下的.gitconfig，添加如下内容：12[core] excludesfile = /Users/mac/.gitignore_global 1、注意：mac替换成你自己的电脑名称 顺便把以下内容一起写入：12[alias] lg = log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' 这段文字的意思是给git log配置一个别名：git lg，可以更优雅地显示提交日志，不信你试试。当然，原有的git log可以正常使用。 工程配置1、在工程目录下touch .gitignore2、在Github上的忽略配置上找到对应的忽略配置，写入.gitignore 其他问题如果本地或远端已经产生需要忽略的文件，问题仍然没有得到解决。 作如下操作： git rm --cached file_path git commit -m &quot;xxoo&quot; git push 注意：git rm --cached file_path只是删除暂存区的文件，本地的文件不会删除，而git rm file_path则会删除文件。]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>git</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 终端配置：oh-my-zsh + Solarized 配色方案]]></title>
    <url>%2FMac-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9Aoh-my-zsh-Solarized-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[1. 安装 oh-my-zsh2. 下载solarized3. 打开终端 -&gt; 偏好设置 -&gt; 描述文件 -&gt; 导入文件，导入 solarized/osx-terminal.app-colors-solarized/Solarized Dark ansi.terminal，设置通用下的默认描述文件为Solarized Dark ansi。 4. 附：git log 配置：终端运行：1git config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'" 重启终端即可。]]></content>
      <categories>
        <category>trick</category>
      </categories>
      <tags>
        <tag>trick</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac安装Python3和PyCharm更换Python版本]]></title>
    <url>%2FMac%E5%AE%89%E8%A3%85Python3%E5%92%8CPyCharm%E6%9B%B4%E6%8D%A2Python%E7%89%88%E6%9C%AC.html</url>
    <content type="text"><![CDATA[打开终端，Homebrew（自行Google）一行命令安装Python3：1brew install python3 安装完成后，打开PyCharm偏好设置，找到Project interpreter，即可更换python版本。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《活在当下》摘录]]></title>
    <url>%2F%E3%80%8A%E6%B4%BB%E5%9C%A8%E5%BD%93%E4%B8%8B%E3%80%8B%E6%91%98%E5%BD%95.html</url>
    <content type="text"><![CDATA[这本书写的朴实无华，基本都是作者本人的一些亲身经历和感受，恰是那份真实，直击我心，给了我莫大的启发和帮助。 读至精彩处，如醍醐灌顶，读罢全书，却无法书写读完的感受。可能我阅历尚浅，不足以描述它给我带来的潜移默化的触动。 我相信以后我还会再来翻看它的，不同的阶段，常看常新。既然无法成文，先作点摘录如下。 生命其实可以被看做一种物质，它是以时间为单位的。我们大部分人的生命长度看似相近，但是在这相近数量的生命里，我们能够萃取的精华却是大相径庭。生命的宽度与高度完全取决于我们以什么样的态度和方式去生活。我们每天把各种食物以最快的速度塞进嘴里，同时可能还在闲谈、思考事情或是看电视。这样不但对食物的味道没有什么感觉，甚至还会影响消化。我们以同样的态度和方式对待我们的生命，沉浸在对过去的回忆中，执着于对未来的幻想中，我们看起来在历经生命的过程，实际上却错过了它。结果不仅人生索然无味，而且身心问题一大堆。 许多灵修体系的精髓其实就是一个片刻接一个片刻地活在当下，全身心专注地生活。这样的生活，几近于道。世界闻名的越南高僧一行禅师，一本深具启发的书《一步一莲花》，在书中写道： 生命的意义只能从当下去寻找 逝者已矣，来者不可追 如果我们不反求当下 就永远探触不到生命的脉动 最有效的自我发掘过程，始终是先静默，并倾听静默，然后写下我所听到的，而所有透过我的笔端刻书在纸上的文字，我总是第一个受益者。 真实刹那的另一个说法是“全神贯注”。全神贯注是东方许多的传统思想之一，特别是佛教的核心概念。简言之，就是讲全副心神贯注在眼前手边的事物上，让心灵毫无杂念地去体验当下。 他说麻木生活和行动的人，一不小心就会坠入行尸走肉的泥沼里。我们顺着时间走下去，眼光却不看着当下，只着意于未来，之后则怀疑，为什么不曾走到任何能给自己有持久成就感的目的地。 整个20世纪的后半段，我们都在为明天而活，对当下所付出的时间则少之又少，我们为未来计划、为未来担忧，然后不知不觉中，当生命走到了尽头才醒悟：我们一心一意计较已发生或希望到来的事，却忘了享受当下的每一个片刻；我们都变成“为生活而做准备”的专家，同时也变成“现在就充分享受活着”的低能儿；我们为事业做准备，为休假做准备，为周末做准备，为退休而准备——总括起来，我们其实是在为了生命终了做准备。 快乐与满意的差别在哪里？满意基本上是一种精神上的满足，它代表完成了某件你有所为而为的事——一项计划、一次交谈、一顿美食。比如，新书的进度又完成了一章，我会觉得很满意；发表了一场演说而且颇受好评，我会觉得满意；把柜子清理干净，我也会觉得很满意；总之就是有某件事情完成了。 快乐则比较倾向情绪方面的满足。当我在某本书的某一章里，写出了自己都叹为观止的语句，我会觉得很快乐；演讲后，有人前来和我分享感触，我深有同感，会觉得很快乐；我望着衣橱里的某件衣服，回想起曾经穿着它度过的一个有趣的夜晚，我会觉得很快乐。 快乐只存在于每一个刹那的当下，也只在当下可得。快乐降临的那一刹那，绝不会是我们存心去找寻快乐的时候，因为一旦存心追求，我们的心就已不在“此时此地”，而是到“别处”去了。如果我们能让自己回到现在，全神贯注于手边的事物，快乐便会不求自来。“快乐”（happiness）这个词源自古英语里的“hap”，指机会或运气（不论好坏）——意思就是人的遭遇（happens）。换句话说，照词源上的解释，“快乐”应该是“所有当下的经历”。所以尽管我们会说“我要快乐起来”，基本上我们已经把自己投射到未来去了；而快乐，依照定义，是只存于当下的这一刻。 你也曾是个快乐的高手——在你还是个孩子的时候。儿童是创造快乐的专家，他们还没有学会按捺住心中的欢欣，所以可以尽情尽兴！ 英文present具有双重意义，可指此时此刻的现在，也指礼物或赠与物。 如果我们想求得内心真正的平静与纯真，我们必须面对一个事实——所有的痛苦、悲伤、不愉快，都是生命时常出现、不可或缺的一部分。我们不可能永远快乐，心理学家荣格这么说过：有多少个白天，就有多少个黑夜，一生之中，黑夜与白天所占的时间一样长，没有黑暗就显不出欢乐时刻的光明；失去了悲伤，快乐也就无由存在了。 在我们能与对方异地而处之前，永远不要批评。 希望我能帮你找到一直潜藏在你心中，你却避而不见的情感和力量。也希望我能为你剥开经年累月积下的层层不经心与不在意，好让你想起此生存在的真正意义。 活着的时候，最好能记住：死亡即将来到，而我们不知道它降临的确切时间。这能让我们随时保持警觉，提醒我们趁着机会还在，要尽情地活着。是该有人常常告诉我们：来日无多。然后我们才可能将生命中的每一天、每一分、每一秒发挥到极致。不论你想做什么，现在就去做吧！明日复明日，明日何其多……]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>活在当下</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊【折腾】的重要性]]></title>
    <url>%2F%E8%81%8A%E8%81%8A%E3%80%90%E6%8A%98%E8%85%BE%E3%80%91%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7.html</url>
    <content type="text"><![CDATA[本文转载于：https://program-think.blogspot.com/2017/04/The-Importance-of-Zheteng.html 引子前不久写了篇关于 Linux 的博文。看到博客评论区中有一些“关于折腾的抱怨”。之前俺写其它教程（比如：翻墙、操作系统虚拟机），也看到过类似的抱怨。 关于折腾的抱怨，俺总结下来有两类： 其一，“从不折腾的人”抱怨折腾太麻烦（这类抱怨往往是泛泛的） 其二，“有过折腾经历的人”抱怨折腾太麻烦（这类抱怨往往是有具体所指的） 所以今天就来聊聊“折腾”这个话题。 名词定义：何为“折腾”为了避免某些人抬杠，先界定一下关键术语——“折腾”一词指的是啥？ 在下面的讨论中，“折腾”一词指的是： 在你【不熟悉】的领域中干某些事情（如果是你【熟悉】的领域，那属于“轻车熟路”，不能算“折腾”） 这些事情通常带有某种“探索/钻研”的性质（通常颇费周折） 这些事情通常要耗费一定的时间和精力（能很快搞定的，就不能算“折腾”） 这些事情通常具有不确定的结果（你不清楚是否能得到期望的结果）。 举例： 针对软件的折腾（比如：Linux） 针对硬件的折腾（比如：树莓派） 针对网络的折腾（比如：翻墙） …… “折腾”与“自学能力”◇“自学能力”的重要性 博客的读者们应该都明白这玩意儿的重要性吧？俺随便说几点： 比如：信息时代会有很多新生事物。你以前在学校课堂里学到的知识/技能已经无法应对这些新生事务，你需要通过自学来搞定它们。 比如：在信息时代，知识的半衰期会变短。你以前在学校课堂里学到的知识/技能，等到你工作时，有些已经过时（失效）了。你需要通过自学来更新这部分过时的知识。 比如：如今的职场竞争会比以往更激烈（信息流动加快使得人才流动加快）。自学能力强的人无疑会有更大的优势。 …… ◇两者的关系 前面俺强调了：折腾的前提是——在你【不熟悉】的领域。 在这种领域中，你多半要通过自学，掌握某些知识或技能，让“不熟悉的领域”变为“熟悉的领域”。 所以，喜欢折腾的人，他/她的自学能力会经常得到锻炼。 当然啦，“经常锻炼自学能力”不一定就表示“自学能力很强”，但至少好于那些“从来没有得到锻炼的人”。 “折腾”与“解决问题能力”◇“解决问题能力”的重要性 说到这个，俺又要趁机来恶毒攻击一下咱们天朝的教育体制了 :) 如果你回顾一下学校（小学/中学/大学）里面的考试或课后作业，大部分的题目都有标准答案（理工科尤其明显）。 但是当你进入职场后，很多工作中的问题，其解决方法是多种多样的，【没有标准答案】。 这两类问题的解题思路是完全不同滴—— 【有】标准答案的问题，解题的思维过程通常是【收敛式】； 【没有】标准答案的问题，解体的思维过程通常是【发散式】。 有很多学校中的优秀生，他们很擅长于考试，但是在工作中的表现却令人难以恭维。因为他们擅长的【收敛式思维】，在工作中通常用不上。 ◇两者的关系 “折腾”与“解题能力”有哪些关系捏？ 当你在不熟悉的领域中折腾，通常不会一帆风顺——整个过程必然会碰到各种各样的问题（困难和障碍），这些问题往往是没有标准答案滴。换句话说，折腾中碰到问题，【不同于】你在学校中碰到的考题，而【更接近于】你在实际工作中碰到问题。 所以，经常折腾的人，会有更多的机会去锻炼他/她的【发散思维能力】。也就可以更多地弥补学校教育在这方面的缺陷。 “折腾”与“知识面/知识结构”◇知识面的重要性 如今这个信息时代，【复合型人才】更有竞争优势。所谓的“复合型”，其主要特征【之一】就是“知识面比较广”。这类人往往兼具多个不同领域的技能。 就拿自己来现身说法——简述一下：维护目前这个博客，大概需要哪些技能？ 基本的写作能力是必不可少滴——如果写出来的文章狗屁不通，就没人看了； 翻墙是必不可少滴——俺必须把博客搭建在墙外，才能防止真理部的和谐； 信息安全也是必不可少滴——否则早就被跨省追捕了； 懂一些 Web 开发的技能（CSS 和 JS）是有好处滴——有助于俺把博客界面搞得好看/好用； 除了上面这些，因为俺博客聊到了“政治、历史、心理学、管理、编程”这几类话题，所以俺在这几个领域多少还算略懂（不敢妄称精通）。 ◇什么样的知识结构才是合理的（有优势的） 前面提到了“知识面的广度”。但仅仅有广度是【不够】滴。良好的知识结构，应该兼具【广度】与【深度】。 至于“深度”与“广度”要如何搭配才比较好，可以看俺多年前的一篇博文《如何完善自己的知识结构》。 ◇两者的关系 那么，“折腾”与“知识面/知识结构”有啥关系捏？ 比如说：你正在折腾 A领域 的某个事物，在折腾的过程中可能会依赖到相关领域的知识（比如说 B领域 和 C领域）。而 B领域 和 C领域 可能是你之前所不了解的。为了搞定 A领域，你就需要顺便去了解 B领域 和 C领域。无形中，你的知识面就拓宽了。 举个栗子： 某个技术菜鸟去折腾翻墙，当此人搞定之后，通常也顺便学会了一些网络相关的知识（比如：代理、VPN …） 如果此人是通过 VPS 来搭建翻墙代理，说不定还顺便学会了一些 Linux 系统管理方面的知识。 “折腾”与“动手实践能力”◇两种不同的领域 所有的领域可以分为两类——“记忆型”与“实践型”。 （注：这两个术语是俺拍脑袋临时起的名儿，如果你有更恰当的叫法，欢迎告知俺） 所谓的“记忆型”，意思就是说：你只需要依靠记忆力就可以掌握该领域。 而“实践型”则完全不同——要掌握这种类型的领域，光靠记忆力是肯定不够滴，一定要经过动手实践。 举例： “记忆型”的例子比较少：历史、艺术鉴赏… “实践型”的例子比较多：所有的体育项目、所有的棋牌游戏和电子游戏、烹调、编程、管理、艺术创作…… 对于“实践型”的领域，不管你看了多少相关的书籍，记住了多少相关的知识，最后都要经过实践，才能最终掌握该领域。套用一句古话就是：纸上得来终觉浅，绝知此事要躬行。 举例： 比如说下围棋——如果某人从来没有实际下过，即使此人看了 N 多的棋谱，看了 N 多的围棋理论书籍，也不能算是“会下棋”。 学编程也类似——俺一直强调学编程（尤其是新人学编程）要：一边看书一边动手写点小程序练手。 ◇两者的关系 俺个人认为：凡是需要折腾的领域，都是实践型的领域。 而经常折腾的好处在于：每次折腾都是在锻炼你的动手实践能力。 “折腾”与“心理舒适区”◇啥是“心理舒适区”？ 两年前（2015）写过一篇《什么是【真正的】兴趣爱好？以及它有啥好处？》，其中正好聊过“心理舒适区”这个概念。下面这段直接引用那篇博文。 首先来解释一下，何为“心理舒适区”。这玩意儿，洋文称之为“Comfort Zone”，用来描述一种“心理状态”。处于这种状态，你会感觉到放松，没有压力和焦虑。 如果你处于某个环境中，在该环境下所需要的行为你都可以轻松搞定。那么，你就处于“心理舒适区”。 举例： 上网闲逛 看电视剧 看娱乐节目 ◇“走出心理舒适区”的重要性 几乎所有的个人能力，如果要想得到提升，都需要你跳出“心理舒适区”。 比如说那些优秀的体操运动员，他们需要不断练习自己【不熟悉】的动作，这样才能提高；反之，如果某个体操运动员总是练习自己最拿手的动作，那是没有长进的（或者说，长进非常有限）。 ◇为啥大部分人都【无法】走出心理舒适区？ 首先，人都是惰性的。 停留在心理舒适区，极大地满足了人的惰性。 要离开心理舒适区，就要克服这种惰性；这通常需要动用意志力，而且需要一定的技巧。 大多数人的意志力是偏弱的；即使是少数意志力较强的人，其中还有一定比例是缺乏运用技巧的。 如果你对这个结论有所怀疑，不妨去观察一下：大部分人在闲暇时间都在干嘛。你就会发现：大部分人都在用一些【轻松的/消遣性的/娱乐性的】活动来打发时光。 ◇两者的关系 前面说过：折腾的往往是自己不熟悉的领域，所以折腾的过程往往会碰到一些障碍和困难。 而搞定这些障碍和困难，通常需要你跳到“心理舒适区”【之外】。 所以，经常折腾的人，就经常需要挑战困难和障碍，于是也就有更多机会去练习——如何跳出心理舒适区。 聊聊那些“不折腾”的理由或借口说完了“心理舒适区”，顺便列几个反面教材——关于“不折腾的理由或借口”。 常见的理由/借口有如下几种： ◇抱怨“无用功” 很多人觉得：如果折腾某个东西，最后没有搞出来（失败了），那就白白浪费了时间，成为“无用功”。 这个理由非常有迷惑性（尤其是在天朝这个功利主义非常盛行的社会）。 实际情况是：即使你折腾某个东西最后失败了，也【不会】是无用功。 因为在这个过程中，你会有很多收获——包括前面提到的几种能力提升和知识面的拓展。 ◇抱怨“时间不够” 这可能是最常见的一种抱怨（借口）——说自己工作太忙，没有空闲的时间去折腾其它东西。 首先，拿网上流传的一句话来反驳此借口——时间就像乳沟，只要你愿意挤，总是有的。 然后，来分析一下俺博客的读者群，应该大部分是学生或者白领/蓝领。 对于在校的学生 （不管是大学生还是中学生）肯定是是有闲暇时间的（比如寒暑假）。 即使是高三年很忙，只要等高考结束，之后那个假期总归是空闲的。 对于工作中的上班族 很多人抱怨“加班”占用时间。 试问：有多少公司是一年365天，天天都加班（完全没有周末和节假日）；而且每天（无一例外）都加班到深夜，一回家就上床睡觉，然后一觉醒来就又去上班。这样的公司，就算有，占总体的比例肯定也是微乎其微的。 还有一些人抱怨“养小孩”占用时间。 这种借口同样是站不住脚滴。“养小孩”确实会占用一些业余时间，但比例肯定达不到100%；而且特别占时间的，通常是小孩刚出生的开头三五年。 所以，绝大部分上班族肯定是有闲暇时间的。 ◇抱怨“精力不够” 另一种常见的抱怨是：上班已经很累，下班回家哪还有精力去折腾其它东西。 首先，很多人发这种抱怨是有夸大其辞的嫌疑。 其次，退一步讲，就算有【少数工作】是每天都很累以至于每天下班回家都精疲力竭。但你至少还有周末的双休日可用啊。每年有52个星期，单算双休日就有一百多天呢！（这还没算上国定假日） ◇抱怨“技能不够” 有这种抱怨的人，要么是找借口，要么是太缺乏自信。 在如今这个互联网很普及的时代（天朝网民据说已经6亿或7亿了），很多需要折腾的事物，都可以在网上找到教程，甚至是手把手的傻瓜教程。有了教程（尤其是傻瓜教程），折腾的门槛已经大大降低了。 （至于如何在网上找到教程，可以参考《如何挖掘网络资源》系列博文） 当然啦，即使有了再完备的教程，你依然会在折腾的过程中碰到一些困难和障碍。所以“教程的存在”并【不会】影响你锻炼“解决问题的能力”。 ◇小结 上述所有这些，如果是【理由】的话，那都是不成立的；如果是【借口】的话，那都可以归咎于——不愿意离开心理舒适区。 为啥很多人都在找借口捏？因为大部分人【不】愿意承认：自己总是停留在心理舒适区；并且大部分人更【不】愿意承认：自己无法离开心理舒适区。所以，他们需要找各种借口来掩饰。 俺写本文的目的在本文最后，稍微透露一下俺写本文的动机。 可能大多数读者会【误以为】：俺写这篇是想劝那些不喜欢折腾的人改变习惯，多多折腾。 NO，NO，NO！这不是俺的本意。 前面说了：那些不喜欢折腾的人，无法（难以）跳出心理舒适区。这是由他们的本性（意志力、观念、性格 …）决定的。而一个人的本性，是【无法】轻易改变滴。所以，俺当然【不指望】：靠这样一篇短短的博文，就能改变他们的本性。 那俺为啥还要写这篇博文捏？写此文的目的是：鼓励那些已经走上折腾之路的同学们，希望他们能在这条路上走得足够远。【好好折腾，天天向上】]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《成为乔布斯》]]></title>
    <url>%2F%E8%AF%BB%E3%80%8A%E6%88%90%E4%B8%BA%E4%B9%94%E5%B8%83%E6%96%AF%E3%80%8B.html</url>
    <content type="text"><![CDATA[乔布斯去世后，关于他的报道、传记和电影等层出不穷，我都没有读过或看过。偶尔看到一些关于他的片段，对他的总体印象就是：牛逼、偏执、有点渣。 今年看到《成为乔布斯》出版，外界评价颇高，去亚马逊买了电子书。很快就看完了2/3，很期待看到iPhone的问世，同时竟然有些舍不得看完，断断续续地看完了剩下的章节。自此，乔布斯在我心里才算有了一个较为清晰的轮廓。他是个天才，审美独特，创意非凡，富有人格魅力，他也是个普通人，热爱家庭，内心充满温暖。 我一直认为，iPhone4是苹果最辉煌的产品。乔布斯去世后，苹果依然在成功的轨道上滑行，却少了一份“惊艳”。 iPhone的问世，是乔布斯多年工作经验和人生阅历的沉淀。纵观苹果的各个产品，都有它符合时代潮流却又卓尔不群的特质，不同产品的内在又有相同之处，它们都归一于苹果精神。精神这种东西，很难概括，它呈现的具体而又独特，本身却抽象而宽泛。在我看来，苹果精神里分量最重的就是那句著名的Think different。而每个人的外在，反应的都是他的内在，Think different必然也是乔布斯内在灵魂里非常重要的特质。 时势造英雄，就算没有乔布斯，也会有someone改变世界，但不是乔布斯那样。很可惜，我们没能看到乔布斯3.0的时代，他更深厚的内在精神再也不能通过伟大的产品传递给我们。 没有人可以成为乔布斯，谁都可以改变世界，但乔布斯只有一个。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>乔布斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何提升行动力：人类行动心理学的有效Hack]]></title>
    <url>%2F%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E8%A1%8C%E5%8A%A8%E5%8A%9B%EF%BC%9A%E4%BA%BA%E7%B1%BB%E8%A1%8C%E5%8A%A8%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E6%9C%89%E6%95%88Hack.html</url>
    <content type="text"><![CDATA[人為什麼會拖延、人為什麼行動力很差。近些年心理學已經取得了突破性研究成果。普通人思考目標的時候，使用的是目標意圖, 是： 我要做什麼… 但是，有位天才心理學家Peter Gollwitzer發現目標意圖這樣的思考範式，反而很難達成目標，於是，他對自己的實驗對象，使用了一種替代範式。強迫實驗對象，使用一種稱之為：執行意圖的思考範式來思考。結果令人驚訝，人們更容易克服拖延症、達成目標。 什麼是執行意圖？就是使用if…then…的思考範式。比如， 不要再說，我要學Ruby。 而是說，如果我要學習Ruby，那麼，今天晚上就裝上環境。 當你關於行動與目標，長年累月這麼思考，最終建立自動化機制，那麼行動力慢慢就變強大了。如果…那麼…成為生命中的一部分。我要…這種句式，就從自己的語言體系中死掉了。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乔布斯2005斯坦福大学演讲中英文全文]]></title>
    <url>%2F%E4%B9%94%E5%B8%83%E6%96%AF2005%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6%E6%BC%94%E8%AE%B2%E4%B8%AD%E8%8B%B1%E6%96%87%E5%85%A8%E6%96%87.html</url>
    <content type="text"><![CDATA[Stanford Report, June 14, 2005 ‘You’ve got to find what you love,’ Jobs says This is the text of the Commencement address by Steve Jobs, CEO of Apple Computer and of Pixar Animation Studios, delivered on June 12, 2005. I am honored to be with you today at your commencement from one of the finest universities in the world. I never graduated from college. Truth be told, this is the closest I’ve ever gotten to a college graduation. Today I want to tell you three stories from my life. That’s it. No big deal. Just three stories. The first story is about connecting the dots. I dropped out of Reed College after the first 6 months, but then stayed around as a drop-in for another 18 months or so before I really quit. So why did I drop out? It started before I was born. My biological mother was a young, unwed college graduate student, and she decided to put me up for adoption. She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided at the last minute that they really wanted a girl. So my parents, who were on a waiting list, got a call in the middle of the night asking: “We have an unexpected baby boy; do you want him?” They said: “Of course.” My biological mother later found out that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers. She only relented a few months later when my parents promised that I would someday go to college. And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents’ savings were being spent on my college tuition. After six months, I couldn’t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life. So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made. The minute I dropped out I could stop taking the required classes that didn’t interest me, and begin dropping in on the ones that looked interesting. It wasn’t all romantic. I didn’t have a dorm room, so I slept on the floor in friends’ rooms, I returned coke bottles for the 5?? deposits to buy food with, and I would walk the 7 miles across town every Sunday night to get one good meal a week at the Hare Krishna temple. I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be priceless later on. Let me give you one example: Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed. Because I had dropped out and didn’t have to take the normal classes, I decided to take a calligraphy class to learn how to do this. I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great. It was beautiful, historical, artistically subtle in a way that science can’t capture, and I found it fascinating. None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography. If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, its likely that no personal computer would have them. If I had never dropped out, I would have never dropped in on this calligraphy class, and personal computers might not have the wonderful typography that they do. Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards ten years later. Again, you can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something - your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life. My second story is about love and loss. I was lucky - I found what I loved to do early in life. Woz and I started Apple in my parents garage when I was 20. We worked hard, and in 10 years Apple had grown from just the two of us in a garage into a $2 billion company with over 4000 employees. We had just released our finest creation - the Macintosh - a year earlier, and I had just turned 30. And then I got fired. How can you get fired from a company you started? Well, as Apple grew we hired someone who I thought was very talented to run the company with me, and for the first year or so things went well. But then our visions of the future began to diverge and eventually we had a falling out. When we did, our Board of Directors sided with him. So at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating. I really didn’t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down - that I had dropped the baton as it was being passed to me. I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley. But something slowly began to dawn on me - I still loved what I did. The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over. I didn’t see it then, but it turned out that getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. It freed me to enter one of the most creative periods of my life. During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife. Pixar went on to create the worlds first computer animated feature film, Toy Story, and is now the most successful animation studio in the world. In a remarkable turn of events, Apple bought NeXT, I retuned to Apple, and the technology we developed at NeXT is at the heart of Apple’s current renaissance. And Laurene and I have a wonderful family together. I’m pretty sure none of this would have happened if I hadn’t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it. Sometimes life hits you in the head with a brick. Don’t lose faith. I’m convinced that the only thing that kept me going was that I loved what I did. You’ve got to find what you love. And that is as true for your work as it is for your lovers. Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle. My third story is about death. When I was 17, I read a quote that went something like: “If you live each day as if it was your last, someday you’ll most certainly be right.” It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: “If today were the last day of my life, would I want to do what I am about to do today?” And whenever the answer has been “No” for too many days in a row, I know I need to change something. Remembering that I’ll be dead soon is the most important tool I’ve ever encountered to help me make the big choices in life. Because almost everything - all external expectations, all pride, all fear of embarrassment or failure - these things just fall away in the face of death, leaving only what is truly important. Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart. About a year ago I was diagnosed with cancer. I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn’t even know what a pancreas was. The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months. My doctor advised me to go home and get my affairs in order, which is doctor’s code for prepare to die. It means to try to tell your kids everything you thought you’d have the next 10 years to tell them in just a few months. It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes. I lived with that diagnosis all day. Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor. I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery. I had the surgery and I’m fine now. This was the closest I’ve been to facing death, and I hope its the closest I get for a few more decades. Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept: No one wants to die. Even people who want to go to heaven don’t want to die to get there. And yet death is the destination we all share. No one has ever escaped it. And that is as it should be, because Death is very likely the single best invention of Life. It is Life’s change agent. It clears out the old to make way for the new. Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it is quite true. Your time is limited, so don’t waste it living someone else’s life. Don’t be trapped by dogma - which is living with the results of other people’s thinking. Don’t let the noise of other’s opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary. When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation. It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch. This was in the late 1960’s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras. It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, and overflowing with neat tools and great notions. Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue. It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous. Beneath it were the words: “Stay Hungry. Stay Foolish.” It was their farewell message as they signed off. Stay Hungry. Stay Foolish. And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish. Thank you all very much. Steve Jobs说，你得找出你爱的 (You’ve got to find what you love.)。 以下是苹果计算机公司与Pixar动画制作室执行长Steve Jobs在2005年六月12日对全体史丹佛大学毕业生的演讲内容。 今天，有荣幸来到各位从世界上最好的学校之一毕业的毕业典礼上。我从来没从大学毕业。说实话，这是我离大学毕业最近的一刻。今天，我只说三个故事，不谈大道理，三个故事就好。 第一个故事，是关于人生中的点点滴滴怎么串连在一起。 我在里德学院（Reed college）待了六个月就办休学了。到我退学前，一共休学了十八个月。那么，我为什么休学？ 这得从我出生前讲起。我的亲生母亲当时是个研究生，年轻未婚妈妈，她决定让别人收养我。她强烈觉得应该让有大学毕业的人收养我，所以我出生时，她就准备让我被一对律师夫妇收养。但是这对夫妻到了最后一刻反悔了，他们想收养女孩。所以在等待收养名单上的一对夫妻，我的养父母，在一天半夜里接到一通电话，问他们「有一名意外出生的男孩，你们要认养他吗？」而他们的回答是「当然要」。后来，我的生母发现，我现在的妈妈从来没有大学毕业，我现在的爸爸则连高中毕业也没有。她拒绝在认养文件上做最后签字。直到几个月后，我的养父母同意将来一定会让我上大学，她才软化态度。 十七年后，我上大学了。但是当时我无知选了一所学费几乎跟史丹佛一样贵的大学，我那工人阶级的父母所有积蓄都花在我的学费上。六个月后，我看不出念这个书的价值何在。那时候，我不知道这辈子要干什么，也不知道念大学能对我有什么帮助，而且我为了念这个书，花光了我父母这辈子的所有积蓄，所以我决定休学，相信船到桥头自然直。当时这个决定看来相当可怕，可是现在看来，那是我这辈子做过最好的决定之一。当我休学之后，我再也不用上我没兴趣的必修课，把时间拿去听那些我有兴趣的课。 这一点也不浪漫。我没有宿舍，所以我睡在友人家里的地板上，靠着回收可乐空罐的五先令退费买吃的，每个星期天晚上得走七里的路绕过大半个镇去印度教的 Hare Krishna神庙吃顿好料。我喜欢Hare Krishna神庙的好料。追寻我的好奇与直觉，我所驻足的大部分事物，后来看来都成了无价之宝。举例来说： 当时里德学院有着大概是全国最好的书法指导。在整个校园内的每一张海报上，每个抽屉的标签上，都是美丽的手写字。因为我休学了，可以不照正常选课程序来，所以我跑去学书法。我学了serif与san serif字体，学到在不同字母组合间变更字间距，学到活版印刷伟大的地方。书法的美好、历史感与艺术感是科学所无法捕捉的，我觉得那很迷人。 我没预期过学的这些东西能在我生活中起些什么实际作用，不过十年后，当我在设计第一台麦金塔时，我想起了当时所学的东西，所以把这些东西都设计进了麦金塔里，这是第一台能印刷出漂亮东西的计算机。如果我没沉溺于那样一门课里，麦金塔可能就不会有多重字体跟变间距字体了。又因为Windows抄袭了麦金塔的使用方式，如果当年我没这样做，大概世界上所有的个人计算机都不会有这些东西，印不出现在我们看到的漂亮的字来了。当然，当我还在大学里时，不可能把这些点点滴滴预先串在一起，但是这在十年后回顾，就显得非常清楚。 我再说一次，你不能预先把点点滴滴串在一起；唯有未来回顾时，你才会明白那些点点滴滴是如何串在一起的。所以你得相信，你现在所体会的东西，将来多少会连接在一块。你得信任某个东西，直觉也好，命运也好，生命也好，或者业力。这种作法从来没让我失望，也让我的人生整个不同起来。 我的第二个故事，有关爱与失去。 我好运－年轻时就发现自己爱做什么事。我二十岁时，跟Steve Wozniak在我爸妈的车库里开始了苹果计算机的事业。我们拼命工作，苹果计算机在十年间从一间车库里的两个小伙子扩展成了一家员工超过四千人、市价二十亿美金的公司，在那之前一年推出了我们最棒的作品－麦金塔，而我才刚迈入人生的第三十个年头，然后被炒鱿鱼。要怎么让自己创办的公司炒自己鱿鱼？好吧，当苹果计算机成长后，我请了一个我以为他在经营公司上很有才干的家伙来，他在头几年也确实干得不错。可是我们对未来的愿景不同，最后只好分道扬镳，董事会站在他那边，炒了我鱿鱼，公开把我请了出去。曾经是我整个成年生活重心的东西不见了，令我不知所措。 有几个月，我实在不知道要干什么好。我觉得我令企业界的前辈们失望－我把他们交给我的接力棒弄丢了。我见了创办HP的David Packard跟创办Intel的Bob Noyce，跟他们说我很抱歉把事情搞砸得很厉害了。我成了公众的非常负面示范，我甚至想要离开硅谷。但是渐渐的，我发现，我还是喜爱着我做过的事情，在苹果的日子经历的事件没有丝毫改变我爱做的事。我被否定了，可是我还是爱做那些事情，所以我决定从头来过。 当时我没发现，但是现在看来，被苹果计算机开除，是我所经历过最好的事情。成功的沉重被从头来过的轻松所取代，每件事情都不那么确定，让我自由进入这辈子最有创意的年代。 接下来五年，我开了一家叫做NeXT的公司，又开一家叫做Pixar的公司，也跟后来的老婆谈起了恋爱。Pixar接着制作了世界上第一部全计算机动画电影，玩具总动员，现在是世界上最成功的动画制作公司。然后，苹果计算机买下了NeXT，我回到了苹果，我们在NeXT发展的技术成了苹果计算机后来复兴的核心。我也有了个美妙的家庭。 我很确定，如果当年苹果计算机没开除我，就不会发生这些事情。这帖药很苦口，可是我想苹果计算机这个病人需要这帖药。有时候，人生会用砖头打你的头。不要丧失信心。我确信，我爱我所做的事情，这就是这些年来让我继续走下去的唯一理由。你得找出你爱的，工作上是如此，对情人也是如此。你的工作将填满你的一大块人生，唯一获得真正满足的方法就是做你相信是伟大的工作，而唯一做伟大工作的方法是爱你所做的事。如果你还没找到这些事，继续找，别停顿。尽你全心全力，你知道你一定会找到。而且，如同任何伟大的关系，事情只会随着时间愈来愈好。所以，在你找到之前，继续找，别停顿。 我的第三个故事，关于死亡。 当我十七岁时，我读到一则格言，好像是「把每一天都当成生命中的最后一天，你就会轻松自在。」这对我影响深远，在过去33年里，我每天早上都会照镜子，自问：「如果今天是此生最后一日，我今天要干些什么？」每当我连续太多天都得到一个「没事做」的答案时，我就知道我必须有所变革了。 提醒自己快死了，是我在人生中下重大决定时，所用过最重要的工具。因为几乎每件事－所有外界期望、所有名誉、所有对困窘或失败的恐惧－在面对死亡时，都消失了，只有最重要的东西才会留下。提醒自己快死了，是我所知避免掉入自己有东西要失去了的陷阱里最好的方法。人生不带来，死不带去，没什么道理不顺心而为。 一年前，我被诊断出癌症。我在早上七点半作断层扫描，在胰脏清楚出现一个肿瘤，我连胰脏是什么都不知道。医生告诉我，那几乎可以确定是一种不治之症，我大概活不到三到六个月了。医生建议我回家，好好跟亲人们聚一聚，这是医生对临终病人的标准建议。那代表你得试着在几个月内把你将来十年想跟小孩讲的话讲完。那代表你得把每件事情搞定，家人才会尽量轻松。那代表你得跟人说再见了。 我整天想着那个诊断结果，那天晚上做了一次切片，从喉咙伸入一个内视镜，从胃进肠子，插了根针进胰脏，取了一些肿瘤细胞出来。我打了镇静剂，不醒人事，但是我老婆在场。她后来跟我说，当医生们用显微镜看过那些细胞后，他们都哭了，因为那是非常少见的一种胰脏癌，可以用手术治好。所以我接受了手术，康复了。 这是我最接近死亡的时候，我希望那会继续是未来几十年内最接近的一次。经历此事后，我可以比之前死亡只是抽象概念时要更肯定告诉你们下面这些： 没有人想死。即使那些想上天堂的人，也想活着上天堂。但是死亡是我们共有的目的地，没有人逃得过。这是注定的，因为死亡简直就是生命中最棒的发明，是生命变化的媒介，送走老人们，给新生代留下空间。现在你们是新生代，但是不久的将来，你们也会逐渐变老，被送出人生的舞台。抱歉讲得这么戏剧化，但是这是真的。 你们的时间有限，所以不要浪费时间活在别人的生活里。不要被信条所惑－盲从信条就是活在别人思考结果里。不要让别人的意见淹没了你内在的心声。最重要的，拥有跟随内心与直觉的勇气，你的内心与直觉多少已经知道你真正想要成为什么样的人。任何其它事物都是次要的。 在我年轻时，有本神奇的杂志叫做Whole Earth Catalog，当年我们很迷这本杂志。那是一位住在离这不远的Menlo Park的Stewart Brand发行的，他把杂志办得很有诗意。那是1960年代末期，个人计算机跟桌上出版还没发明，所有内容都是打字机、剪刀跟拍立得相机做出来的。杂志内容有点像印在纸上的Google，在Google出现之前35年就有了：理想化，充满新奇工具与神奇的注记。 Stewart跟他的出版团队出了好几期Whole Earth Catalog，然后出了停刊号。当时是1970年代中期，我正是你们现在这个年龄的时候。在停刊号的封底，有张早晨乡间小路的照片，那种你去爬山时会经过的乡间小路。在照片下有行小字： 求知若饥，虚心若愚。 那是他们亲笔写下的告别讯息，我总是以此自许。当你们毕业，展开新生活，我也以此期许你们。 求知若饥，虚心若愚。 非常谢谢大家。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>乔布斯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客迁移记]]></title>
    <url>%2F%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0.html</url>
    <content type="text"><![CDATA[几年前就折腾过一个的域名，也是用的 hexo + github 搭建的，后来没有维护，域名也过期了。现在想重新拾起，发现域名已被注册，只好注册了现在的这个域名，又折腾了一阵子，才有了现在这个站点。 其实比较懒，一直没有写作的习惯，如今年岁渐长，愈发觉得时光过得飞快，回忆往昔，只觉如梦一场，竟想不起过去的许多事，而文字能记下一些点滴，于是决定坚持写下去。这大半年算是养成了写东西的习惯，有的私下琐记，有的公之于网络。 现在有了这个新的角落，自然想把以前写的一些杂乱文章搬过来，却不能尽数迁移，只好选择其中一部分作为保留。 恩，差不多就是这样。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>notes</tag>
      </tags>
  </entry>
</search>
