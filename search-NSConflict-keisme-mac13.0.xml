<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift 5.6 新特性]]></title>
    <url>%2FSwift-5-6-%E6%96%B0%E7%89%B9%E6%80%A7.html</url>
    <content type="text"><![CDATA[不可用条件（#unavailable）#available 用于根据不同的平台、版本进行条件编译： 12345if #available(iOS 15, *) &#123; // 通配符 * 表示 Apple 所有平台，如果是 iOS，则要求 &gt;= 15&#125; else &#123; // iOS 15 以下&#125; Swift 5.6 引入了 #unavailable ，它和 #available 的意思正好相反，下面的示例和上面示例中的 else 分支表达的意思是一样的。 123if #unavailable(iOS 15) &#123; // iOS 15 以下&#125; 它也支持同时指定多个平台： 123if #unavailable(iOS 15, macOS 12) &#123; // iOS 15 以下， macOS 12 以下&#125; 注意：使用 #unavailable 使不需要通配符，我们的目的是为了使用它具体指出不可用的环境，使用 * 会造成歧义。 类型占位符（、 ?）Swift 5.6 支持使用占位符 _ 或 _? 表示需要声明的类型，我们无需显示地指定类型，编译器会根据上下文自行推断。 12345let complexType: [Int: _] = [1: [1], 2: [[2]], 3: [(1, 2)], 4: [&#123;&#125;]]// 编译器会将 complexType 的类型推断为 [Int : [Any]]let complexType: [Int: _] = [1: [1], 2: [[2]], 3: [(1, 2)], 4: nil]// 编译器会将 complexType 的类型推断为 [Int : [Any]?] CodingKeyRepresentable 协议先来看看下面的代码，我们想对字典进行编码，这个字典有点特殊，它的 key 是枚举类型。 1234567891011121314151617enum AnimalType: String, Codable &#123; case cat case dog&#125;struct Animal: Codable &#123; var name: String var age: String&#125;let pets: [AnimalType: Animal] = [ .cat: .init(name: "Mao", age: "3"), .dog: .init(name: "Biu", age: "2")]let petsData = try! JSONEncoder().encode(pets)print(String(decoding: petsData, as: UTF8.self))// ["cat",&#123;"name":"Mao","age":"3"&#125;,"dog",&#123;"name":"Biu","age":"2"&#125;] 打印的结果与预期不符，因为非 String/Int 类型的 key 值，Swift 在转换时无法正确处理。如果我们将这段编码后的字符串以 JSON 形式向服务端传参时，就会出现错误。为此，我们不得不做额外的工作来进行数据转换。 Swift 5.6 新增的 CodingKeyRepresentable 协议很好的解决了这个问题，它支持自定义 key 值的数据类型。我们让 AnimalType 遵循该协议，再次打印的结果与预期一致： 1// &#123;"dog":&#123;"name":"Biu","age":"2"&#125;,"cat":&#123;"name":"Mao","age":"3"&#125;&#125; any 关键字any 和 Any、AnyObject、AnyClass 很像，但它们的关系就像雷锋和雷峰塔。Any 开头的一般表示的是擦除类型信息的类型，any 是一个关键字，用来修饰一种特殊的类型：存在类型（existential types）。 存在类型是一个比较抽象的概念，如果一定要给它下个定义，我会这样描述它：作为类型的协议。比如下面的代码， 123456789101112131415protocol UIMode &#123; var color: Color &#123; get set &#125;&#125;struct LightMode: UIMode &#123; var color: Color = .white&#125;struct DarkMode: UIMode &#123; var color: Color = .black&#125;struct ModeManager &#123; var mode: UIMode&#125; 在 ModeManager 中 ，协议 UIMode 也被称作存在类型。我们使用一个 DarkMode() 实例来初始化 ModeManager 后，还可以使用 LightMode() 来替换原有的 mode。在编译期，mode 的类型是 UIMode。在运行时，mode 真正的类型是 LightMode、DarkMode 或其它任意遵循该协议的类型，它的值是可以动态分发的。 我们可以把存在类型的值想象成一个盒子，这个盒子可以动态地容纳所有符合该协议类型的值。只要是符合类型的值，相互之间可以动态替换。 我们将上面的代码结合泛型改造一下： 123456struct ModeManager&lt;T: UIMode&gt; &#123; var mode: T&#125;var manager = ModeManager(mode: DarkMode())manager.mode = LightMode() 这段代码是无法通过编译的，因为我们在初始化 ModeManager 时传入的是 DarkMode 类型，泛型在编译层面就已经将 mode 约束成了 DarkMode 类型，当我们使用 LightMode 类型的值去改变 mode 时，编译器会报错。 通过对比我们可以看出，当协议作为类型时，它也可以被称为存在类型。如果协议作为泛型的约束，它就无法在运行时动态改变其类型，相应的值只能静态分发。另外，不透明类型中使用 some 关键字修饰的协议，也无法使用不同类型，它要求我们始终使用遵循该协议的特定类型。 动态虽好，但效率不及静态。存在类型带来了性能损耗，但它是我们常用的写法。因此 Swift 5.6 引入了 any 关键字，目的就是提醒我们存在类型的负面影响。同时，我们应该尽可能地避免使用 any。 123struct ModeManager &#123; var mode: any UIMode&#125; 从 Swift 6 开始，当我们使用存在类型时，编译器会强制要求使用 any 关键字标记，否则会报错。 前文我们提到过，Any 开头的类型一般是擦除类型信息的。它具有一定的动态特性，但会带来一定的性能损耗。这个规律在 SwiftUI 中也是适用的，SwiftUI 中的 AnyView 我们也要慎用。但也不能一概而论，比如 AnyPublisher 我们还是会用到。因此，到底要不要擦除类型信息来换取一定的灵活性，我们要在性能和灵活之间作一个较为平衡的选择。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 并发新体验]]></title>
    <url>%2FSwift-%E5%B9%B6%E5%8F%91%E6%96%B0%E4%BD%93%E9%AA%8C.html</url>
    <content type="text"><![CDATA[引言对于诞生于 2014 年的 Swift 而言，它已不再年轻。至今我还记得初次体验 Swift 时的喜悦之情，比起冗长的 OC 而言，它更加现代、简洁、优雅。但 Swift 的前期发展是野蛮而动荡的，每次发布新版本时都会导致旧项目出现大量的报错和告警，项目迁移工作令开发者苦不堪言。不得不说，Swift 诞生之初就敢于在项目中实践并运用的人，是真的猛士。我是从 Swift 4 才开始将项目逐渐从 OC 向 Swift 迁移的，到 2019 年 Swift 5 实现了 ABI 稳定时，才全面迁移至纯 Swift 开发。 ABI 的稳定象征着 Swift 的成熟，然而在并发编程方面，Swift 却落后了一截。Chris Lattner 早在2017年发表的 《Swift 并发宣言》 中就描绘了令人兴奋的前景。2021 年 Swift 5.5 的发布终于将 Concurrency 加入了标准库，从此，Swift 并发编程变得更为简单、高效和安全。 在此之前，我们通常使用闭包来处理异步事件的回调，如下是一个下载网络图片的示例： 1234567891011func fetchImage(from: String, completion: @escaping (Result&lt;UIImage?, Error&gt;) -&gt; Void) &#123; URLSession.shared.dataTask(with: .init(string: from)!) &#123; data, resp, error in if let error = error &#123; completion(.failure(error)) &#125; else &#123; DispatchQueue.main.async &#123; completion(.success(.init(data: data!))) &#125; &#125; &#125;.resume()&#125; 代码并不复杂，不过这只是针对下载单一图片的场景。我们将需求设计的再复杂一点点：先下载前两张图片（无先后顺序）并展示，然后再下载第三张图片并展示，当三张图片都下载完成后，再展示在 UI 界面。当然，实际开发中一般是先下载的图片先展示，这里的非常规设计只作举例而已。 完整的实现代码变成如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import UIKitclass ViewController: UIViewController &#123; let sv = UIScrollView(frame: UIScreen.main.bounds) let imageViews = [UIImageView(), UIImageView(), UIImageView()] let from = [ "https://images.pexels.com/photos/10646758/pexels-photo-10646758.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500", "https://images.pexels.com/photos/9391321/pexels-photo-9391321.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500", "https://images.pexels.com/photos/9801136/pexels-photo-9801136.jpeg?auto=compress&amp;cs=tinysrgb&amp;dpr=2&amp;w=500" ] override func viewDidLoad() &#123; super.viewDidLoad() sv.backgroundColor = .white view.addSubview(sv) sv.contentSize = .init(width: 0, height: UIScreen.main.bounds.height + 100) imageViews.enumerated().forEach &#123; i, v in v.backgroundColor = .lightGray v.contentMode = .scaleAspectFill v.clipsToBounds = true v.frame = .init(x: 0, y: CGFloat(i) * 220, width: UIScreen.main.bounds.width, height: 200) sv.addSubview(v) &#125; let group = DispatchGroup() let queue = DispatchQueue(label: "fetchImage", qos: .userInitiated, attributes: .concurrent) let itemClosure: (Int, DispatchWorkItemFlags, @escaping () -&gt; ()) -&gt; DispatchWorkItem = &#123; idx, flags, completion in return DispatchWorkItem(flags: flags) &#123; self.fetchImage(from: self.from[idx]) &#123; result in print(idx) switch result &#123; case let .success(image): self.imageViews[idx].image = image case let .failure(error): print(error) &#125; completion() &#125; &#125; &#125; from.enumerated().forEach &#123; i, _ in group.enter() let flags: DispatchWorkItemFlags = (i == 2) ? .barrier : [] queue.async(group: group, execute: itemClosure(i, flags, &#123; group.leave() &#125;)) &#125; group.notify(queue: queue) &#123; DispatchQueue.main.async &#123; print("end") &#125; &#125; &#125;&#125; 这里使用了 GCD 来实现需求，看上去也不是特别复杂，我们还能使用 PromiseKit 来管理事件总线，不直接编写 GCD 层面的代码，使代码更简洁更易读。但是试想一下，实际需求可能更复杂，我们也许要先从服务端获取一些数据后，再下载图片并进行解码以及缓存，同时可能还会有下载音频、视频等任务要处理，这样的情况就更加复杂了。不管有没有使用 PromiseKit 这样优秀的库，随着业务的复杂度增加，都无法回避会越来越明显地暴露出来的问题： 闭包本身难以阅读，还有导致循环引用的潜在风险 回调必须覆盖各种情况，一旦遗漏则难以排查问题所在 Result 虽然较好地处理了错误，但难以解决错误向上传递的问题 嵌套层级太深导致回调地狱 …… async/await 初体验针对上面的这些问题，Concurrency 的解决方案是使用 async/await 模式，该模式在 C#、Javascript 等语言中有着成熟的应用。现在，我们终于可以在 Swift 中使用它了！ 下面是使用 async/await 改造 fetchImage 的代码，这里先了解一下 async 和 await 关键字的基本使用： async：添加在函数末尾，标记其为异步函数 await：添加在调用 async 函数前，表明该处的代码会受到阻塞，直到异步事件返回 1234567891011121314func fetchImage(idx: Int) async throws -&gt; UIImage &#123; // 1 let request = URLRequest(url: .init(string: from[idx])!) // 2 let (data, resp) = try await URLSession.shared.data(for: request) // 3 print(idx, Thread.current) guard (resp as? HTTPURLResponse)?.statusCode == 200 else &#123; throw FetchImageError.badNetwork &#125; guard let image = UIImage(data: data) else &#123; throw FetchImageError.downloadFailed &#125; return image&#125; async throws 表明该函数是异步的、可抛出错误的 URLSession.shared.data 方法的全名如下，因此我们需要使用 try await 来调用该方法 1public func data(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -&gt; (Data, URLResponse) 代码执行到这里时，表明下载图片的异步事件已经结束了 相信你对 async/await 的使用已经有点感觉了：async 用来标记异步事件，await 用来调用异步事件，等待异步事件返回，然后继续执行后面的代码。它和 throws、try 这对关键词很像，几乎总是同时出现在相关场合。有的读者可能会纳闷，为何 try await 和 async throws 的顺序是反的，这里不必纠结，设计如此罢了，而且 try await 好像听上去和写起来更顺一点？ 接下来我们要做的就是调用异步函数 fetchImage，并且需要控制图片的下载顺序，实现代码： 123456789// 1async let image0 = try? fetchImage(idx: 0)async let image1 = try? fetchImage(idx: 1)// 2let images = await [image0, image1]imageViews[0].image = images[0]imageViews[1].image = images[1]// 3imageViews[2].image = try? await fetchImage(idx: 2) async let 可以让多个异步事件同时执行，这里表示同时异步下载前两张图片。 前面我们说了 async 用来标记异步函数，await 用来调用，几乎总是出现在同一场合。而且编译器会去检查调用 async 函数时是否使用了 await，如果没有，则会报错。而这里，我们在调用 fetchImage 时并没有使用 await，依然可以通过编译，是因为在使用 async let 时，如果我们没有显示地使用 try await，Swift 会隐式的实现它，而且能将 try await 的调用时机推迟。 上面的代码，我们将它改成如下也是可以的： 123async let image0 = fetchImage(idx: 0)async let image1 = fetchImage(idx: 1)let images = try await [image0, image1] await 阻塞当前任务，等待上面的两个异步任务返回结果 前两张图片下载完成之后，继续异步下载第三张图片并展示 将上面的代码放在 viewDidLoad 中执行，发现凡是有 async 的地方都报红了。这是因为如果某个函数内部调用了 async 函数，该函数也需要标记为 async，这样才能为函数体内部提供异步环境，并且将异步事件进行传递。而 viewDidLoad 没有被标记为 async，编译器发现了这一问题并报错了。但是，我们不能这样做。因为 viewDidLoad 是重写的 UIViewController 中的方法，它是运行在主线程中的同步函数而且必须如此。 那么这个问题该如何解决呢？Swift 为我们提供了 Task，在创建的 Task 实例闭包中，我们将获得一个新的异步环境，如此，就可以调用异步函数了。Task 就像打破同步环境结界的桥梁，为我们提供了通向异步环境的通道。 我们将上面的代码放在 Task 实例的闭包中，就可以顺利运行程序了。 1234567891011Task &#123; // 1 async let image0 = fetchImage(idx: 0) async let image1 = fetchImage(idx: 1) // 2 let images = try await [image0, image1] imageViews[0].image = images[0] imageViews[1].image = images[1] // 3 imageViews[2].image = try? await fetchImage(idx: 2)&#125; 上面的代码最终的表现结果和改造前还有点细微差别：前两张图片虽然是同时异步下载的，但是会相互等待，直到两张图片都下载完成后，才展示在界面上。这里提供两个思路去实现与之前同样的效果，一是将展示图片的逻辑放在 fetchImage 方法中，另一种是使用 Task 解决，参考代码如下： 12345678910Task &#123; let task1 = Task &#123; imageViews[0].image = try? await fetchImage(idx: 0) &#125; let task2 = Task &#123; imageViews[1].image = try? await fetchImage(idx: 1) &#125; let _ = await [task1.value, task2.value] imageViews[2].image = try? await fetchImage(idx: 2)&#125; 关于 Task、TaskGroup 并不在本文的讨论范畴，后面会有单独的章节去详述。 这里要补充说明的是，当我们使用 async let 时，实际上是在当前任务中隐式地创建了一个新的 task，或者叫子任务。async let 就像一个匿名的 Task，我们没有显示地创建它，也不能使用本地变量存储它。所以 Task 相关的 value、cancel() 等属性和方法，我们都无法使用。 async let 其实就是一个语法糖，我们可以使用它应对多数场景下的异步事件处理。如果要处理的异步事件数量多且关系复杂，甚至涉及到事件的优先级，那么使用 Task、TaskGroup 是更明智的选择。 Refactor to Async如果你想把之前基于回调的异步函数迁移至 async/await（最低支持 iOS 13），Xcode 内置了非常方便的操作，能够快速地进行零成本的迁移和兼容。 如图所示，选中相应的方法，右键选择 Refactor，会有三种选择： Convert Function to Async：将当前的回调函数转换成 async，覆盖当前函数 Add Async Alternative：使用 async 改写当前的回调函数，基于改写后的函数结合 Task 再提供一个回调函数 Add Async Wrapper：保留当前的回调函数，在此基础上提供一个 async 函数 从上我们可以得知 Wrapper 支持的 iOS 版本范围是大于 Alternative 的，我们可以根据项目的最低支持版本按需操作： &lt; iOS 13，选 3 &gt;= iOS 13 整体迁移至 async：选 1 保留回调函数 API：选 3 或 1 小结async/await 简化了异步事件的处理，我们无需和线程直接打交道，就可以写出安全高效的并发代码。回调机制经常衍生出的面条式代码也不复存在，我们可以用线性结构来清晰地表达并发意图。 这得益于结构化并发的编程范式在背后做理念支撑，结构化并发的思想和结构化编程是类似的。每个并发任务都有自己的作用域，并且有着明确且唯一的入口和出口。不管这个并发任务内部的实现有多复杂，它的出口一定是单一的。 我们把要执行并发任务想象成一根管道，水流就是管道内要执行的任务。在非结构化编程的世界，子任务会生成许多的管道分支，水流会从不同的分支出口流出去，也可能会遇到故障，我们需要在不同的出口去处理水流结果，出口越多，我们越手忙脚乱。而结构化编程的世界里，我们无需关心各个分支出口，只要守住管道另一端的唯一出口就可以了，分支出口不管多复杂，水流最终会回到管道的出口。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Concurrency</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 协议的实战应用]]></title>
    <url>%2FSwift-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8.html</url>
    <content type="text"><![CDATA[Source code 随着 Swift 和 SwiftUI 的发展，协议所扮演的角色越来越重要，面向协议编程（POP）已成为日常开发的常规操作。本文不会细谈协议的基础概念（需要了解基础的同学，可以移步官方文档：Protocols），而是以实际案例来阐述协议的运用，希望读者能有所获益。 1、自定义 Button我们现在需要自定义一个按钮控件，要求可以快速生成不同样式的按钮，还能方便地维护和扩展。 我们首先定义一个协议，该协议只定义了一个方法 config(_:) 来配置按钮的样式： 1234protocol ButtonStyle &#123; func config(_ button: UIButton)&#125; 然后，我们定义一个按钮控件 Button，该类暴露了一个 style(_:) 方法来快速生成不同样式的按钮。Buton 的初始化方法里是该控件的一些公共配置，这里使用了笔者自己写的一个小工具来实现链式调用，方法名和系统 api 基本一致。 12345678910111213141516171819202122232425262728293031import KZRazorclass Button&lt;S: ButtonStyle&gt;: UIButton &#123; override var isHighlighted: Bool &#123; didSet &#123; self.alpha = isHighlighted ? 0.6 : 1.0 &#125; &#125; private var style: S? @discardableResult func style(_ style: S) -&gt; Self &#123; self.style = style style.config(self) return self &#125; override init(frame: CGRect) &#123; super.init(frame: frame) self.kz.padding(top: 8, bottom: 8, left: 16, right: 16) .kz.backgroundColor(.white) .kz.cornerRadius(8) .kz.titleColor(.darkText) &#125; required init?(coder: NSCoder) &#123; fatalError("init(coder:) has not been implemented") &#125;&#125; 我们现在来实现一个带模糊效果的按钮，定义一个遵循 ButtonStyle 协议的类并实现相应的方法： 1234567891011121314151617class BlurButtonStyle: ButtonStyle &#123; private var blurStyle: UIBlurEffect.Style init(blurStyle: UIBlurEffect.Style) &#123; self.blurStyle = blurStyle &#125; func config(_ button: UIButton) &#123; let blurEffect = UIBlurEffect(style: blurStyle) let blurEffectView = UIVisualEffectView(effect: blurEffect) blurEffectView.isUserInteractionEnabled = false button.kz.addSubview(blurEffectView) &#123; make in make.edges.equalToSuperview() &#125; &#125;&#125; 然后，我们就可以通过下面的方法来调用了： 1Button().style(BlurButtonStyle(blurStyle: .systemThinMaterialLight)).kz.title("Hello World!") 但是在写代码的时候不够智能，我们必须知道 ButtonStyle 的具体类型才能实现相应的 style，我们可以通过下面的改进来提供更友好的 api，在调用的时候，直接通过点语法就可以获得编译器的智能提示。 12345extension ButtonStyle where Self == BlurButtonStyle &#123; static func blur(style: UIBlurEffect.Style) -&gt; Self &#123; Self.init(blurStyle: style) &#125;&#125; 上面的调用代码就可以改写成： 1Button().style(.blur(style: .systemThickMaterialLight)).kz.title("Hello World!") 文章开头的图片还提供了 .automatic 和 .shadow 两种样式，思路与上面一致，参考代码如下： 123456789101112131415class DefaultButtonStyle: ButtonStyle &#123; func config(_ button: UIButton) &#123;&#125;&#125;extension ButtonStyle where Self == DefaultButtonStyle &#123; static var automatic: Self &#123; Self() &#125;&#125;class ShadowButtonStyle: ButtonStyle &#123; func config(_ button: UIButton) &#123;&#125;&#125;extension ButtonStyle where Self == ShadowButtonStyle &#123; static var shadow: Self &#123; Self() &#125;&#125; 对于 shadow 样式的按钮，为了获取到按钮的真实尺寸并添加阴影效果，我们在 Button 类重写 layoutSubViews 方法： 123456override func layoutSubviews() &#123; super.layoutSubviews() if self.style is ShadowButtonStyle &#123; self.kz.shadow(radius: 5, opacity: 0.1, color: .black, offset: .zero) &#125; &#125; 以上就是一个自定义按钮的实现，如果你熟悉 SwiftUI，就会发现这样的代码结构和 SwiftUI 中的各种视图的 style 实现思路是一致的。在遵循协议的基础上，我们可以放肆地修改和新增功能而将影响范围降至最小，这也意味着我们可以更好地理解我们的代码和进行单元测试。 我们并没有完全摒弃 OOP，而是与 POP 结合起来一起使用，都是为了更好地组织和管理代码。POP 并不能完全取代 OOP 这样的纵向继承方式，但它的横向扩展特性补充了 OOP 的不足。合纵连横，方为上策。 2、一个基础路由的实现 如上图，我们现在需要实现一个路由，通过路由来跳转到 A、B 界面，一个不带参数，一个带参数，同时，我们还需要能够在跳转过程中加入自定义转场动画。 首先，我们定义如下协议： 1234public protocol Routable &#123; var destination: UIViewController &#123; get &#125;&#125; Routable 协议只定义一个核心属性，就是路由跳转的控制器。这里我们并没有定义要跳转的方法，因为我们的需求是要在跳转过程中可以加入自定义转场动画，所以将跳转方法交给后文介绍的 Transition 协议来管理。 接着，我们定一个枚举类型，实现该协议。 12345678910111213141516enum Router1 &#123; case pageA case pageB(params: String)&#125;extension Router1: Routable &#123; var destination: UIViewController &#123; switch self &#123; case .pageA: return AController() case let .pageB(params): return BController(params: params) &#125; &#125;&#125; Router1 这里可以理解为某个功能模块，比如我们还有其它功能模块，可以依样画葫芦，将各个模块的业务实现组织在一起，方便管理和维护。比如，RouterAuth、RouterShop、RouterCart 等。 下一步我们实现一个单例类 Router，该类实现了 open 和 close 两个方法，分别用于界面的跳转和返回。 1234567891011121314class Router &#123; static let shared = Router() func open(_ target: Routable, transition: Transition, fromVc: UIViewController? = nil, completion: (() -&gt; Void)? = nil) &#123; // open &#125; func close(_ viewController: UIViewController?, transition: Transition, completion: (() -&gt; Void)? = nil) &#123; // close &#125;&#125; 路由的雏形基本出来了，接下来就是让 Transition 实例去实现 open 和 close 方法。根据这个思路，Transiton 协议定义如下： 1234567891011protocol Transition &#123; func open(_ viewController: UIViewController, fromVc: UIViewController?, completion: (() -&gt; Void)?) func close(_ viewController: UIViewController?, completion: (() -&gt; Void)?)&#125;extension Transition &#123; func open(_ viewController: UIViewController, fromVc: UIViewController?, completion: (() -&gt; Void)?) &#123;&#125; func close(_ viewController: UIViewController?, completion: (() -&gt; Void)?) &#123;&#125;&#125; 我们在 Router 中的 open 和 close 方法内加上 Transition 实例的调用方法，更新后的代码： 1234567891011121314class Router &#123; static let shared = Router() func open(_ target: Routable, transition: Transition, fromVc: UIViewController? = nil, completion: (() -&gt; Void)? = nil) &#123; transition.open(target.destination, fromVc: fromVc, completion: completion) &#125; func close(_ viewController: UIViewController?, transition: Transition, completion: (() -&gt; Void)? = nil) &#123; transition.close(viewController, completion: completion) &#125;&#125; 光有转场，没有动画，是转不起来的，所以我们需要给 Transition 协议新增如下两个属性（其中 animated 是用来标记是否需要动画的，以应对不需要动画的场景）： 12var animated: Bool &#123; get set &#125;var animator: Animator? &#123; get set &#125; Animator 协议继承自系统的 UIViewControllerAnimatedTransitioning 协议： 1234protocol Animator: UIViewControllerAnimatedTransitioning &#123; var duration: TimeInterval &#123; get set &#125;&#125; 接下来，我们来实现一个渐变的 Push。如果你熟悉自定义转场，那么下面的代码就很好理解了。 UIApplication.navigationController 是通过 extension 实现的一个小功能，用来获取 app 当前的导航控制器，方便我们在非控制器界面获取导航控制器，读者不必纠结具体实现。 123456789101112131415161718192021222324252627282930313233343536373839404142final class PushTransition: NSObject, Transition &#123; var animated: Bool = true var animator: Animator? private weak var fromVc: UIViewController? private var navigationController: UINavigationController? &#123; if fromVc != nil &#123; return fromVc!.navigationController &#125; return UIApplication.navigationController &#125; init(animator: Animator?, animated: Bool) &#123; self.animator = animator self.animated = animated &#125; func open(_ viewController: UIViewController, fromVc: UIViewController?, completion: (() -&gt; Void)?) &#123; self.fromVc = fromVc navigationController?.delegate = self CATransaction.begin() CATransaction.setCompletionBlock(completion) navigationController?.pushViewController(viewController, animated: animated) CATransaction.commit() &#125;&#125;extension Transition where Self == PushTransition &#123; static func push(animator: Animator?, animated: Bool = true) -&gt; Self &#123; Self(animator: animator, animated: animated) &#125;&#125;extension PushTransition: UINavigationControllerDelegate &#123; func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationController.Operation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; animator &#125;&#125; 我们只差最后一步的动画了，前面我们已经定了 Animator 协议，现在我们实现一个 FadeAnimator： 1234567891011121314151617181920212223242526final class FadeAnimator: NSObject, Animator &#123; var duration: TimeInterval = 0.25 init(duration: TimeInterval = 0.25) &#123; self.duration = duration &#125; func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; duration &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; guard let toView = transitionContext.view(forKey: .to) else &#123; return &#125; let containerView = transitionContext.containerView containerView.addSubview(toView) toView.alpha = 0 UIView.animate(withDuration: duration) &#123; toView.alpha = 1.0 &#125; completion: &#123; _ in transitionContext.completeTransition(!transitionContext.transitionWasCancelled) &#125; &#125;&#125; 代码很简单，除了实现我们自己定义的 duration 属性，还需要实现 UIViewControllerAnimatedTransitioning 的协议方法。 我们的工作已接近尾声，现在尝试调用一下： 123456789Router.shared.open( Router1.pageB(params: textView.text), transition: .push(animator: FadeAnimator(duration: 2)), fromVc: nil) &#123; print("Did push") &#125;// animator 传参，这里是直接使用的 FadeAnimator 实例// 笔者尝试过使用 extenstion Animator 的方式增加点语法调用，比如 .fade(duration: 2)// 编译器始终无法通过。。。这里作了妥协，如果有更优雅的实现，欢迎交流 结果和预期一致： 同理，对于 pop 操作，我们也可以用同样的思路实现，这里就不展开来说了，有兴趣的读者可以参看源码。 至此，一个基础的路由就实现了。如果需要实现更为复杂的功能比如 Universal Links 跳转、加入手势驱动转场等，读者可自行研究和实现。 Source code]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Protocol</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 协议属性和方法的默认实现]]></title>
    <url>%2FSwift-%E5%8D%8F%E8%AE%AE%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[协议是 Swift 中头等重要的内容，在实际开发中，我们会大量地使用面向协议编程。 方法的默认实现一个协议中可能会定义许多的属性和方法，有些属性和方法却不是遵循该协议的对象必须实现的，又或者，我们不希望在每个遵循该协议的对象中写入过多重复的代码。 我们可以给协议的属性和方法添加默认的实现来解决上面的问题，我们先来看看方法的默认实现。 第一种方式是使用 @objc 来实现： 12345678910@objc protocol Human &#123; @objc optional func read() func eat()&#125;class Man: Human &#123; func eat() &#123;&#125;&#125; Human 协议定义了两个方法，其中 eat 为必须实现的，而 read 并不是必须的，使用 @objc optional 表明该方法为可选。然后我们让 Man 这个类遵循 Human 协议，只需要实现 eat 方法即可。 第二种实现方式是使用 extension 给协议添加一个默认实现方法： 123456789101112131415protocol Human &#123; func read() func eat()&#125;extension Human &#123; func read() &#123;&#125;&#125;struct Man: Human &#123; func eat() &#123;&#125;&#125; 我们在协议扩展中默认实现了 read 方法，因此在结构体 Man 中就无需实现该方法了。 注意这里我将 Man 的类型从 class 改为了 struct ，这样是没有问题的。但是如果我们在第一种实现方式中，将 Man 的类型从 class 改为 struct，编译器就会报错。 因为使用 @objc 标记的协议，只有遵循 NSObject 的 class 类才能遵循该协议，这也是它的局限性所在。比如 struct 、enum 都不能遵循该协议，关联类型更是无法在该协议中使用。 使用 extension 为协议添加默认实现虽然需要多写点代码，但却摆脱了上面的限制，笔者个人习惯使用第二种实现方式，这也是笔者推荐的方式。 属性的默认实现我们给 Human 添加一个属性 age 和 height，然后添加一个新的结构体 Woman ，代码变成如下： 12345678910111213141516171819202122protocol Human &#123; var age: Int &#123; get set &#125; var heigth: CGFloat &#123; get set &#125; func read() func eat()&#125;extension Human &#123; func read() &#123;&#125;&#125;struct Man: Human &#123; func eat() &#123;&#125;&#125;struct Woman: Human &#123; func eat() &#123;&#125;&#125; 毫不意外，编译器报错了，因为 Man 和 Woman 没有实现协议中的 age 和 height 属性，我们当然可以在 Man 和 Woman 中实现这两个属性，但是如果还有其它遵循 Human 协议的结构体，我们不想在每个结构体中都把这两个属性实现一遍，而是希望能有个默认值。那么该如何实现呢？很遗憾 extension 无法实现我们的需求，我们需要另辟蹊径。 在软件设计中，许多问题都可以通过添加中间层来实现。这里我们可以借鉴这个思路，先定义一个如下结构体将各个属性包装起来： 12345struct HumanProperties &#123; var age: Int = 0 var height: CGFloat = 30.0&#125; 然后我们在 Human 协议中添加一个属性： 123456protocol Human &#123; var hp: HumanProperties &#123; get set &#125; func read() func eat()&#125; 然后我们在扩展中添加属性： 1234567891011121314extension Human &#123; var age: Int &#123; get &#123; hp.age &#125; set &#123; hp.age = newValue &#125; &#125; var height: CGFloat &#123; get &#123; hp.height &#125; set &#123; hp.height = newValue &#125; &#125; func read() &#123;&#125;&#125; 然后在遵循 Human 协议的结构体中实现 hp 属性： 1234567891011struct Man: Human &#123; var hp = HumanProperties() func eat() &#123;&#125;&#125;struct Woman: Human &#123; var hp = HumanProperties() func eat() &#123;&#125;&#125; 不管 Human 有多少属性要实现，我们都可以使用 HumanProperties 包装起来，并且为之提供了默认值。 方法参数的默认值我们为 eat 方法添加如下参数： 1func eat(breakfast: String, lunch: String, dinner: String) 假设我们现在正在健康饮食阶段，想给 breakfast 和 dinner 添加两个默认值来约束 Man 的行为。 遗憾的是，协议方法并不支持带默认值的参数。 我们可以故技重施，将上面的参数包装起来： 12345struct Recipe &#123; var breakfast: String = "Bread &amp; Milk" var lunch: String var dinner: String = "Fruits"&#125; 然后将方法修改为： 1func eat(_ food: Recipe) 接着实现该方法： 123456789struct Man: Human &#123; var hp = HumanProperties() func eat(_ food: Recipe) &#123; print(food) &#125;&#125; 调用： 12var p = Man()p.eat(.init(lunch: "Rice &amp; Beef &amp; Vegetables"))]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Protocol</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI、Combine 简明教程 App：Eul]]></title>
    <url>%2FSwiftUI%E3%80%81Combine%20%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%20App%EF%BC%9AEul.html</url>
    <content type="text"><![CDATA[简介Eul 是一款 SwiftUI &amp; Combine 教程 App（支持 iPhone、iPad、Mac），以文章（文字、图片、代码）配合真机示例（Xcode 12+、iOS 14+，macOS 11+）的形式呈现给读者。 笔者意在尽可能使用简洁明了的语言阐述 SwiftUI &amp; Combine 相关的知识，使读者能快速掌握并在 iOS 开发中实践。读者若能从中获益，笔者深感欣慰。如有笔误之处，恳请斧正，不甚感激。 下面是 App 内实图： iOS： macOS： 下载链接iOS/macOS：https://apps.apple.com/cn/app/eul/id1541991958 联系反馈 邮箱：bruce8.0@outlook.com 微博：Bruce2077 twitter：Bruce_2077]]></content>
      <categories>
        <category>Products</category>
      </categories>
      <tags>
        <tag>SwiftUI</tag>
        <tag>Products</tag>
        <tag>App</tag>
        <tag>Eul</tag>
        <tag>Combine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI PreferenceKey]]></title>
    <url>%2FSwiftUI-PreferenceKey.html</url>
    <content type="text"><![CDATA[下图所示是一个常规的登录界面，只需少量代码即可实现： 123456789101112131415161718192021struct ContentView : View &#123; @State private var email = "" @State private var password = "" var body: some View &#123; Form &#123; HStack &#123; Text("电子邮箱") TextField("请输入", text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) &#125; HStack &#123; Text("密码") TextField("请输入", text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) &#125; &#125; &#125;&#125; 但是通常我们为了美观，会将左边的文字列等宽对齐，也许固定宽度是个不错的想法，但是可扩展性太差，我们如何解决这个问题呢？ 常规的思路就是，获取文字列所有的内容的宽度，取最大值，重绘界面即可。那么问题来了，如何获取这个最大值呢？答案就是 PreferenceKey，它可以收集视图树中子视图的数据，回传给父视图（跨层级亦可）。这里我们需要获取尺寸，还用到了 GeometryReader。 改造后的效果和代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct ContentView : View &#123; @State private var email = "" @State private var password = "" // 保存、更新文字列所需要的合适宽度，这里是最大值 @State private var textWidth: CGFloat? var body: some View &#123; Form &#123; HStack &#123; Text("电子邮箱") .frame(width: textWidth, alignment: .leading) .background(TextBackgroundView()) TextField("请输入", text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) &#125; HStack &#123; Text("密码") .frame(width: textWidth, alignment: .leading) .background(TextBackgroundView()) TextField("请输入", text: $email) .textFieldStyle(RoundedBorderTextFieldStyle()) &#125; &#125; .onPreferenceChange(TextWidthPreferenceKey.self) &#123; (value) in print(value) textWidth = value.max() &#125; &#125;&#125;struct TextBackgroundView: View &#123; var body: some View &#123; GeometryReader &#123; gr in Rectangle() .fill(Color.clear) .preference(key: TextWidthPreferenceKey.self, value: [gr.size.width]) &#125; &#125;&#125;struct TextWidthPreferenceKey: PreferenceKey &#123; // 偏好值没有被设定时，使用默认值 static var defaultValue: [CGFloat] = [] // 收集视图树中的数据 // nextValue 的闭包是惰性调用的，只有需要用到它时才会去获取相应的值 static func reduce(value: inout [CGFloat], nextValue: () -&gt; [CGFloat]) &#123; value.append(contentsOf: nextValue()) &#125;&#125; 有一点需要注意，为什么我们要使用 TextBackgroundView 来作为背景回传所需要的值呢？因为我们期望 Form 列表的布局是根据子视图的布局来更新的，而子视图又依赖父视图传入的宽度值，这样形成了一个得不到结果的死循环。而 TextBackgroundView 可以打破这个僵局，父视图所依赖的布局不再是文字的布局，而是背景层的视图布局。 补充说明一下，SwiftUI 的视图层级是不同于 UIKit 的，在 UIKit 中，背景是控件的属性，而 SwiftUI 中，.background 会在视图树中生成一个新的视图，是独立与所修饰的控件的。 另外有一点令我不解的是，既然我是要获取最大宽度，只需要在 TextWidthPreferenceKey 将关联类型设置为 CGFloat 即可，在 reduce 方法中写入 value = max(value, nextValue())，然后在 onPreferenceChange 中将最大值传给 textWidth ，这样不是更简单吗？但是事与愿违，这样达不到我们想要的效果，观察控制台，我发现确实可以获取到最大宽度值，但是不会更新视图布局，百思不得其解，网上也没找到合理的解释。暂且放下，以后再研究一下这个问题。 参考： PreferenceKey’s reduce method demystified Inspecting the View Tree – Part 1: PreferenceKey SwiftUI 小技巧：透過 PreferenceKey 簡單對齊視圖]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>SwiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI GeometryReader 与坐标系]]></title>
    <url>%2FSwiftUI-GeometryReader-%E4%B8%8E%E5%9D%90%E6%A0%87%E7%B3%BB.html</url>
    <content type="text"><![CDATA[GeometryReader 是一个通过闭包来构建视图的容器，可以返回一个 GeometryProxy 类型的结构体，它包含如下属性和方法，由此我们可以获取当前视图容器（即父视图）的尺寸和位置，绘制以其为参考坐标系的视图。 12345678var safeAreaInsets: EdgeInsets// The safe area inset of the container view.var size: CGSize// The size of the container view.func frame(in: CoordinateSpace) -&gt; CGRect// Returns the container view’s bounds rectangle, converted to a defined coordinate space. 比如，我们需要绘制一个长宽均为父视图一半的矩形： 12345678910struct ContentView: View &#123; var body: some View &#123; GeometryReader &#123; gr in RoundedRectangle(cornerRadius: 10) .fill(Color.blue) .frame(width: gr.size.width * 0.5, height: gr.size.height * 0.5) .position(x: gr.frame(in: .local).midX, y: gr.frame(in: .local).midY) &#125; &#125;&#125; 我们再来看看 GeometryProxy 包含的实例方法：func frame(in: CoordinateSpace) -&gt; CGRect，这里的 CoordinateSpace 是个枚举类型，有以下几种情况： 123case global // 参考系为屏幕case local // 参考系为父视图case named(AnyHashable) // 参考系为自定义 通过这个方法，我们可以获取到当前视图在不同参考系中的位置和尺寸，我们将代码改成如下： 123456789101112131415161718192021222324252627282930313233343536373839struct ContentView: View &#123; var body: some View &#123; VStack(spacing: 10) &#123; text("Top", width: 100, height: 50) HStack(spacing: 10) &#123; text("Left", width: 50, height: 100) roundRect .background(Color.black) text("Right", width: 50, height: 100) &#125; text("Bottom", width: 100, height: 50) &#125; .coordinateSpace(name: "VStack") &#125; var roundRect: some View &#123; GeometryReader &#123; gr in RoundedRectangle(cornerRadius: 10) .fill(Color.blue) .frame(width: gr.size.width * 0.5, height: gr.size.height * 0.5) .position(x: gr.frame(in: .local).midX, y: gr.frame(in: .local).midY) .onTapGesture &#123; print("screen: \(UIScreen.main.bounds)") print("global: \(gr.frame(in: .global))") print("local: \(gr.frame(in: .local))") print("custom: \(gr.frame(in: .named("VStack")))") &#125; &#125; &#125; func text(_ text: String, width: CGFloat, height: CGFloat) -&gt; some View &#123; Text(text) .frame(width: width, height: height) .background(Color.orange) .cornerRadius(10) &#125;&#125; 运行模拟器 iPhone 12 Pro（safeAreaInsets: 47.0, 0.0, 34.0, 0.0），点击蓝色区域，控制台打印如下结果： 1234screen: (0.0, 0.0, 390.0, 844.0)global: (60.0, 107.0, 270.0, 643.0)local: (0.0, 0.0, 270.0, 643.0)custom: (60.0, 60.0, 270.0, 643.0) 这与我们之前所说的枚举类型对应的坐标参考系是一致的。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>SwiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 中的协议、泛型、不透明类型]]></title>
    <url>%2FSwift-%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E3%80%81%E6%B3%9B%E5%9E%8B%E3%80%81%E4%B8%8D%E9%80%8F%E6%98%8E%E7%B1%BB%E5%9E%8B.html</url>
    <content type="text"><![CDATA[在学习 SwiftUI 的过程中，发现对标题中的内容还不甚熟悉，而这些内容是 SwiftUI 中极其重要的部分，不理解就很难熟练地掌握 SwiftUI，故温习并记录，以下内容可视为官方教程的简装版。 协议定义协议规定了实现某一特定功能的方法和属性。 类、结构体、枚举类型都可以遵循协议。 语法123protocol SomeProtocol &#123; // 协议内容&#125; 属性要求属性可以是存储型或计算型，必须明确其可读写性。 12345protocol Cat &#123; var food: String &#123; get set &#125; // 可读写 var color: Color &#123; get &#125; // 只读 static var age: Int &#123; get &#125; // static 用于 class 的类型属性&#125; 方法要求方法可以是实例方法或类方法，方法参数不能使用默认值。 异变方法要求协议中的实例方法可以标记为 mutating，当结构体、枚举这样的值类型实现相应的方法时，需要加上 mutating 关键字，而类作为引用类型，不需要该关键字。 初始化器要求协议可以要求遵循者实现指定的初始化器，只是不需要写初始化器的实体，即大括号里的内容。 1234protocal Cat &#123; init(from: String) init?(color: Color) // 可失败的初始化器&#125; 协议初始化器要求的类实现在遵循协议的类中实现的构造器，可以指定为类的指定构造器或便利构造器，在这两种情况下，必须使用 required 修饰构造器。该修饰符保证：所有遵循该协议的子类，都能有一个明确的继承实现。 123456789101112protocol P &#123; init()&#125;class SomeSuperClass &#123; init() &#123;&#125;&#125;class SomeSubClass: SomeSuperClass, P &#123; // SomeSubClass 遵循协议 P，所以要用 required 修饰 required override init &#123;&#125;&#125; 将协议作为类型使用场合： 在函数、方法或者初始化器里作为形参类型或者返回类型 作为常量、变量或者属性的类型 作为数组、字典或者其他存储器的元素的类型 123456789101112131415161718192021222324252627282930313233343536protocol LifeStyle &#123; func lifeStyle() -&gt; [String]&#125;class Person &#123; var name: String var lifeStyle: LifeStyle init(name: String, lifeStyle: LifeStyle) &#123; self.name = name self.lifeStyle = lifeStyle &#125; func beBetterFrom() -&gt; [String] &#123; return lifeStyle.lifeStyle() &#125; func perf(with addition: String) -&gt; [String] &#123; var newStyle = lifeStyle.lifeStyle() newStyle.append(addition) return newStyle &#125;&#125;struct Recommend: LifeStyle &#123; func lifeStyle() -&gt; [String] &#123; return ["read", "travel"] &#125;&#125;let p = Person(name: "p", lifeStyle: Recommend())print(p.beBetterFrom())/// ["read", "travel"]let newStyle = p.perf(with: "love")print(newStyle)/// ["read", "travel", "love"] 在扩展里添加协议遵循扩展可以补充协议中已存在的内容，或是提供默认的实现，还可以给协议新增内容。 有条件的遵循协议123extension Array where Element: Equatable &#123; // code&#125; 使用扩展声明采纳协议如果一个类型已经遵循类协议的要求，但是还没有声明采纳协议，可以通过一个空的扩展来显式地声明它采纳协议。 1234567891011struct Hamster &#123; var name: String var textualDescription: String &#123; return "A hamster named \(name)" &#125;&#125;extension Hamster: TextRepresentable &#123;&#125;let simonTheHamster = Hamster(name: "Simon")let somethingTextRepresentable: TextRepresentable = simonTheHamsterprint(somethingTextRepresentable.textualDescription) 协议类型的集合1234let things: [TextRepresentable] = [game, d12, simonTheHamster]for thing in things &#123; print(thing.textualDescription)&#125; 协议继承123protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123; // protocol definition goes here&#125; 类专用的协议123protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol &#123; // class-only protocol definition goes here&#125; 协议组合12345678910111213141516protocol Named &#123; var name: String &#123; get &#125;&#125;protocol Aged &#123; var age: Int &#123; get &#125;&#125;struct Person: Named, Aged &#123; var name: String var age: Int&#125;func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123; print("Happy birthday, \(celebrator.name), you're \(celebrator.age)!")&#125;let birthdayPerson = Person(name: "Malcolm", age: 21)wishHappyBirthday(to: birthdayPerson)// Prints "Happy birthday, Malcolm, you're 21!" 协议遵循的检查 如果实例遵循协议 is 运算符返回 true 否则返回 false as? 版本的向下转换运算符返回协议的可选项，如果实例不遵循这个协议的话值就是 nil as! 版本的向下转换运算符强制转换协议类型并且在失败是触发运行时错误 可选协议要求 略 协议扩展略 泛型类型形式参数1func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) 占位符 T 就是类型形式参数，当我们调用函数时，用实际类型来替换类型形参。 泛型类型Swift 允许自定义泛型类型，它们可以使自定义类、结构体、枚举。 123456789struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125; 扩展一个泛型类型12345extension Stack &#123; var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125; 类型约束类型约束语法123func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // function body goes here&#125; 类型约束的应用12345678func findIndex&lt;T: Equatable&gt;(of valueToFind: T, in array:[T]) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 关联类型定义一个协议时，声明一个或多个关联类型是很有用的。关联类型个协议中用到的类型一个占位符名称，直到采纳协议时，才指定实际类型。 关联类型的应用1234567891011121314151617181920212223242526272829protocol Container &#123; associatedtype ItemType mutating func append(_ item: ItemType) var count: Int &#123; get &#125; subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125;struct Stack&lt;Element&gt;: Container &#123; var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // 可省略，应为 Swift 可以推断出此处的关联类型 // typealias ItemType = Element mutating func append(_ item: Element) &#123; self.push(item) &#125; var count: Int &#123; items.count &#125; subscript(i: Int) -&gt; Element &#123; return items[i] &#125;&#125; 给关联类型添加约束123456protocol Container &#123; associatedtype Item: Equatable mutating func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125;&#125; 在关联类型约束里使用协议123456789101112131415161718192021protocol SuffixableContainer: Container &#123; associatedtype Suffix: SuffixableContainer where Suffix.Item == Item func suffix(_ size: Int) -&gt; Suffix&#125;extension Stack: SuffixableContainer &#123; func suffix(_ size: Int) -&gt; Stack &#123; var res = Stack() for i in (count-size)..&lt;count &#123; res.append(self[i]) &#125; return res &#125;&#125;var stackOfInts = Stack&lt;Int&gt;()stackOfInts.append(10)stackOfInts.append(20)stackOfInts.append(30)print(stackOfInts.suffix(2))// "Stack&lt;Int&gt;(items: [20, 30])" 扩展现有类型来指定关联类型Swift 中的 Array 类型已经提供了 Container 协议中的方法和属性，我们只需要用一个空的扩展显示地声明采纳协议即可： 1extension Array: Container &#123;&#125; 现在我们可以把任何 Array 当做一个 Container 使用。 泛型 Where 分句12345678910func allItemsMatch&lt;C1: Container, C2: Container&gt;( _ c1: C1, _ c2: C2) -&gt; Bool where C1.Item == C2.Item &#123; if c1.count != c2.count &#123; return false &#125; for i in 0..&lt;c1.count &#123; if c1[i] != c2[i] &#123; return false &#125; &#125; return true&#125; 带有泛型 Where 分句的扩展123456789extension Container where Item == Double &#123; func average() -&gt; Double &#123; var sum = 0.0 for i in 0..&lt;count &#123; sum += self[i] &#125; return sum / Double(count) &#125;&#125; 泛型下标1234567891011extension Container &#123; // 传入的 indices 形参是一个整数的序列 subscript&lt;Indices: Sequence&gt;(indices: Indices) -&gt; [Item] where Indices.Iterator.Element == Int &#123; var res = [Item]() for i in indices &#123; res.append(self[i]) &#125; return res &#125;&#125; 不透明类型具有不透明返回类型的函数或者方法会隐藏它返回值的具体类型信息，而以它支持的协议进行描述。隐藏类型信息在模块之间调用代码时很好用，因为返回值的具体类型可以保持私有。不同于返回一个协议类型的值，不透明类型保持了类型的身份——编译器可以访问类型信息，但是模块不能。 不透明类型也可以理解为“反向泛型”，泛型受调用者约束，而不透明类型受被调用者约束。 函数不能返回带有 Self 或 associatedtype 的协议，而不透明类型可以。函数可以返回不同的协议类型，不透明类型每次必须返回相同的类型。 12345678910111213141516171819202122232425262728293031323334353637383940protocol UIMode &#123; func color() -&gt; UIColor&#125;struct LightMode: UIMode &#123; func color() -&gt; UIColor &#123; return .white &#125;&#125;struct DarkMode: UIMode &#123; func color() -&gt; UIColor &#123; return .black &#125;&#125;let light = LightMode()let dark = DarkMode()func getMode(isDay: Bool) -&gt; UIMode &#123; isDay ? light : dark&#125;print(getMode(isDay: true).color())print(getMode(isDay: false).color())struct AutoMode: UIMode &#123; var isDay: Bool func color() -&gt; UIColor &#123; isDay ? .white : .black &#125;&#125;func getModeOpaque(isDay: Bool) -&gt; some UIMode &#123; return AutoMode(isDay: isDay)&#125;print(getModeOpaque(isDay: true).color())print(getModeOpaque(isDay: false).color())]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>SwiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI（iOS 14）新增属性包装器（Property Wrapper）]]></title>
    <url>%2FSwiftUI%EF%BC%88iOS-14%EF%BC%89%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%85%E5%99%A8%EF%BC%88Property-Wrapper%EF%BC%89.html</url>
    <content type="text"><![CDATA[@StateObject@StateObject 修饰的对象与 @ObservedObject 一样，都需要遵循 Observable 协议，功能也类似。区别在于，@StateObject 修饰的对象只会在所属的 View 中创建一次并在 View 的生命周期内存储相应的状态，而 @ObservedObject 修饰的对象会随着 View 的重绘生成新的对象，不会在 View 的生命周期内存储该对象的状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Counter: ObservableObject &#123; @Published var count: Int = 0&#125;struct StateObjectView: View &#123; @State private var buttonTitle = "Tap me" var body: some View &#123; VStack &#123; Group &#123; Button(buttonTitle) &#123; buttonTitle = buttonTitle == "Tap me" ? "Tapped" : "Tap me" &#125; CounterView1() CounterView2() &#125; .padding() &#125; &#125;&#125;struct ItemList: View &#123; @State private var items = ["hello", "world"] var body: some View &#123; VStack &#123; Button("Append item to list") &#123; items.append("test") &#125; List(items, id: \.self) &#123; name in Text(name) &#125; CounterView1() CounterView2() &#125; &#125;&#125;struct CounterView1: View &#123; @StateObject var counter1 = Counter() var body: some View &#123; VStack &#123; Text("StateObject count: \(counter1.count)") Button("IncrementStateObject") &#123; counter1.count += 1 &#125; &#125; &#125;&#125;struct CounterView2: View &#123; @ObservedObject var counter2 = Counter() var body: some View &#123; VStack &#123; Text("ObservedObject count: \(counter2.count)") Button("IncrementStateObject") &#123; counter2.count += 1 &#125; &#125; &#125;&#125; 如上代码所示，当我们点击 CounterView1 和 CounterView2 中的按钮时，会给相应的 Counter 实例的 count 属性加 1，一旦我们点击 “Tap me” 按钮，View 会执行重绘，这时 CounterView2 中的 count 会重置为 0，而 CounterView1 中使用 @StateObject 修饰的对象中的 count 仍然持有当前的数据状态。 那么我们应该在什么场景下分别使用这两个属性包装器呢？ 在 View 的生命周期内，需要一直持有并存储对象的状态时，使用 @StateObject 修饰。基本上，绝大多数情况下的 viewModel 都会是这种情况。 只有在少数情况下，View 不需要一直持有该对象，该对象的状态会随着外界的条件改变而刷新自己时，我们才用到 @ObservedObject 修饰，比如上面的例子，如果我们要求点击 “Tap me” 按钮时，count 就重置，就需要用 @ObservedObject 修饰了。 @AppStorage等同于 Userdefaults。 @SceneStorage用于多窗口模式，相当于为每个场景持久化了一个场景值，每个场景只能读取该场景持久化的值。 当场景销毁时，该值也会销毁。建议存储轻量的、不敏感的数据。 @UIApplicationDelegateAdaptor用来调用 AppDelegate 中的生命周期方法。 1234567891011121314class AppDelegate: NSObject, UIApplicationDelegate &#123; &#125;@mainstruct MyApp: App &#123; @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate var body: some Scene &#123; WindowGroup &#123; ContentView() &#125; &#125;&#125; 其它参考之前的文章SwiftUI 中常见的属性包装器（Property Wrapper）概览和今天这篇，只是列举了一些常用的，更多相关内容和使用方法可以参考下面两片佳作： swiftuipropertywrappers All SwiftUI property wrappers explained and compared Source code]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>SwiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI 中常见的属性包装器（Property Wrapper）概览]]></title>
    <url>%2FSwiftUI-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%85%E5%99%A8%EF%BC%88Property-Wrapper%EF%BC%89%E6%A6%82%E8%A7%88.html</url>
    <content type="text"><![CDATA[@State由 SwiftUI 管理的可读写的属性包装器，当修饰的属性值改变的时候，界面会随之更新。由 @State 包装的属性通常用 private 修饰，在 body 内使用。 下面的实例是一个可以切换天气的界面，并且可以控制天气是否可变。 1234567891011121314151617181920212223242526272829303132333435363738394041424344enum Weather: String, CaseIterable &#123; case sun = "Sun" case cloud = "Cloud" case rain = "Rain" case snow = "Snow" var imageName: String &#123; switch self &#123; case .sun: return "sun.max" case .cloud: return "cloud" case .rain: return "cloud.rain" case .snow: return "snow" &#125; &#125;&#125;struct StateView: View &#123; @State private var weather: Weather = .sun @State private var mutableWeather = false var body: some View &#123; VStack &#123; Toggle(isOn: $mutableWeather) &#123; Text(mutableWeather ? "Mutable" : "Immutable") &#125; .padding() // add weather view Spacer() &#125; .navigationBarTitle("Weather", displayMode: .inline) .navigationBarItems(trailing: Button(action: &#123; if self.mutableWeather &#123; let random = Int.random(in: 0..&lt;Weather.allCases.count) self.weather = Weather.allCases[random] &#125; &#125;) &#123; Text(weather.rawValue) &#125;) &#125;&#125; @Binding接下来，我们用自定义的 WeatherView 去展示天气图片，图片会跟随父视图天气变化做相应改变，并且在 WeatherView 中可以通过点击改变天气。这个时候，我们就需要用到 @binding 来做数据的双向绑定。 12345678910111213141516struct WeatherView: View &#123; @Binding var weather: Weather @Binding var mutableWeather: Bool var body: some View &#123; Image(systemName: weather.imageName) .resizable() .scaledToFill() .frame(width: 150, height: 150) .onTapGesture &#123; self.mutableWeather = true let random = Int.random(in: 0..&lt;Weather.allCases.count) self.weather = Weather.allCases[random] &#125; &#125;&#125; 接下来我们在 // add weather view下面添加如下代码： 1WeatherView(weather: $weather, mutableWeather: $mutableWeather) @ObservedObject、@Published、ObservableObject遵循 ObservableObject 协议的类的属性可以用 @Published 包装，在多个界面之间同步数据，只需要将需要监听的实例对象用 @ObservedObject 包装即可。注意：这里适用的对象类型是 class，因为 class 是在内存中共享数据的。 下面是一个可以编辑一个人姓名和年龄的实例，在 EditView 所做的更改，会同步至 Person 界面。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Person: ObservableObject &#123; @Published var name: String @Published var age: Int init(name: String, age: Int) &#123; self.name = name self.age = age &#125;&#125;struct EditView: View &#123; @ObservedObject var person: Person var body: some View &#123; // TextField 只能绑定 String，需要自定义 Binding let bindingAge = Binding&lt;String&gt;(get: &#123; "\(self.person.age)" == "0" ? "" : "\(self.person.age)" &#125;) &#123; value in self.person.age = Int(value) ?? 0 &#125; return Form &#123; TextField("Input name", text: $person.name) TextField("Input age", text: bindingAge) &#125; &#125;&#125;struct ObservedObjectView: View &#123; @ObservedObject private var person = Person(name: "Bruce", age: 30) var body: some View &#123; List &#123; Text(person.name) Text("\(person.age)") &#125; .navigationBarTitle("Person", displayMode: .inline) .navigationBarItems(trailing: NavigationLink(destination: EditView(person: self.person)) &#123; Text("Edit") &#125; ) &#125;&#125; @Environment、EnvironmentValues@Environment 可以让我们在 View 中直接访问预设的环境变量，比如系统是否暗黑模式、系统日历、时区等。 下面是一个可以返回上一个页面的实例，@Environment将.presentationMode绑定在当前的 View，我们可以直接调用presentationMode来获取它的值： 123456789struct EnvironmentView: View &#123; @Environment(\.presentationMode) private var presentationMode var body: some View &#123; Button("Dismiss") &#123; self.presentationMode.wrappedValue.dismiss() &#125; &#125;&#125; 系统为我们提供了许多有用的预设变量，详见 https://developer.apple.com/documentation/swiftui/environmentvalues 我们也可以为预设值注入新值，比如我们将返回按钮标题改为 “Dismiss\nDismiss”，这时可以看见一个换行的按钮，而当我们给.lineLimit注入新值得时候，按钮标题就只有一行了： 1234Button("Dismiss\nDismiss") &#123; self.presentationMode.wrappedValue.dismiss()&#125;.environment(\.lineLimit, 1) 这里只是举个例子，我们使用.lineLimit(1)也能达到同样的效果。 我们也可以自定义 EnvironmentValues： 12345678910struct DismissColorKey: EnvironmentKey &#123; public static let defaultValue = Color.red&#125;extension EnvironmentValues &#123; var dismissColor: Color &#123; set &#123; self[DismissColorKey.self] = newValue &#125; get &#123; self[DismissColorKey.self] &#125; &#125;&#125; 然后我们添加一个新的属性： 1@Environment(\.dismissColor) private var dismissColor 再使用自定义的预设值添加一个红色的返回按钮： 123456Button(action: &#123; self.presentationMode.wrappedValue.dismiss()&#125;) &#123; Text("Red Dismiss") .foregroundColor(dismissColor)&#125; @EnvironmentObject@EnvironmentObject 和 @ObservedObject 很像，都需要遵循 ObservableObject 协议，都可以同步数据状态，但是它具备更强大的功能，那就是子视图可以自动获取父视图注入的环境变量。 比如我们有如下视图层级：A -&gt; B -&gt; C -&gt; D -&gt; E，后一个是前一个视图的子视图。如果我们使用 @ObservedObject 在 A 视图包装一个变量，我们需要在每个视图包装一个变量，将变量一层层传递到 E 视图。而使用 @EnvironmentObject 我们不需要这么复杂，我们在 A 视图声明一个变量后，在 E 视图用 @EnvironmentObject 包装一个变量后，就可以获取到 A 视图注入的环境变量了，而且可以同步数据的修改，这简直是太方便了。要注意的是，如果 E 视图找不到这个环境变量，程序会崩溃，所以要确保 E 视图能获取到注入的环境变量。 12345678910111213141516171819202122232425262728293031323334353637class User: ObservableObject &#123; @Published var name = "Bruce"&#125;struct ViewA: View &#123; var body: some View &#123; ViewB() .frame(width: 300, height: 300) .background(Color.red) &#125;&#125;struct ViewB: View &#123; var body: some View &#123; ViewC() .frame(width: 200, height: 200) .background(Color.black) &#125;&#125;struct ViewC: View &#123; @EnvironmentObject var user: User var body: some View &#123; Text(user.name) .frame(width: 100, height: 100) .background(Color.white) &#125;&#125;struct EnvironmentObjectView: View &#123; private let user = User() var body: some View &#123; ViewA().environmentObject(user) &#125;&#125; ​ Demo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>SwiftUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftFormat 的使用]]></title>
    <url>%2FSwiftFormat-%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[虽然 Xcode 自带格式对齐（Ctrl + i），但是在多人协作的情况下，就很难保证编码风格的统一了，SwiftFormat就是解决这一问题的好工具。 SwiftFormat具有多种使用方式，目前我在实际工作中使用的是CocoaPods集成。具体使用方法： pod &#39;SwiftFormat/CLI&#39;，安装 SwiftFormat TARGETS - Build Phases - New Run Script Phase，添加如下脚本： 1"$&#123;PODS_ROOT&#125;/SwiftFormat/CommandLineTool/swiftformat" . --exclude Pods,Generated 在编译或运行的时候，SwiftFormat会对齐不符合格式的代码。Enjoy it~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode 创建自定义文件模板]]></title>
    <url>%2FXcode-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"><![CDATA[首先，创建我们的自定义模板文件夹： 1mkdir -p ~/Library/Developer/Xcode/Templates/Custom 然后复制系统提供的模板文件，路径如下： 1/Applications/Xcode.app/Contents/Developer/Library/Xcode/Templates/File Templates/Source/Swift File.xctemplate 将Swift File.xctemplate整个文件夹复制到刚才创建的Custom文件夹。 然后我们开始自定义，只需要修改___FILEBASENAME___.swift中的内容即可。 其中涉及到一些宏定义可以参考：Text macros reference。注意：宏定义前后必须加上三个下划线。 然后我们就可以使用了，如图：]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 命名空间（namespace）的实现]]></title>
    <url>%2FSwift-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%88namespace%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/// 实例对象的包装器public struct CCWrapper&lt;WrappedType&gt; &#123; /// 包装后的值 let wrappedValue: WrappedType init(wrappedValue: WrappedType) &#123; self.wrappedValue = wrappedValue &#125;&#125;/// 命名空间协议public protocol NameSpaceWrapper &#123; associatedtype WrapperType var cc: WrapperType &#123; get &#125; static var cc: WrapperType.Type &#123; get &#125;&#125;/// 命名空间协议默认实现public extension NameSpaceWrapper &#123; var cc: CCWrapper&lt;Self&gt; &#123; return CCWrapper(wrappedValue: self) &#125; static var cc: CCWrapper&lt;Self&gt;.Type &#123; return CCWrapper.self &#125;&#125;// 使用extension String: NameSpaceWrapper &#123;&#125;extension CCWrapper where WrappedType == String &#123; var hi: String &#123; return "Hi, I'm \(self.wrappedValue)" &#125; func sayHi(to person: String) &#123; print("\(self.wrappedValue) say hi to \(person)") &#125; static func hi(_ person: String) &#123; print("Hi, \(person)") &#125; &#125;print("Bruce".cc.hi)//Hi, I'm Bruce"Bruce".cc.sayHi(to: "Max")//Bruce say hi to MaxString.cc.hi("Jack")//Hi, Jack]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 关联类型（associatedtype）的使用]]></title>
    <url>%2FSwift-%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B%EF%BC%88associatedtype%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[定义一个协议时，有时在协议定义里声明一个或多个关联类型是很有用的。关联类型给协议中用到的类型一个占位符名称。直到采纳协议时，才指定用于该关联类型的实际类型。关联类型通过 associatedtype 关键字指定。 举个例子： 12345678910111213141516171819202122232425protocol Eat &#123; associatedtype FoodType func eat(_ food: FoodType) -&gt; FoodType&#125;protocol Food &#123; var weight: CGFloat &#123; get set &#125; var desc: String &#123; get set &#125;&#125;struct Meat: Food &#123; var weight: CGFloat var desc: String&#125;struct Vegetable: Food &#123; var weight: CGFloat var desc: String&#125;struct Person&lt;T&gt;: Eat &#123; func eat(_ food: Food) -&gt; Food &#123; return food &#125;&#125; 我们定义了一个 Person，它每天都得吃饭，我们要求它遵循吃饭的协议 Eat，并实现了其中的 eat 方法。在协议 Eat 中我们声明了一个关联类型 FoodType。当 Person 的实例去调用 eat 方法时，我们使用泛型类型去指定之前的占位符 FoodType，那么我们就能清晰地知道 Person 的实例到底吃的是什么。 123456789let p = Person&lt;Food&gt;()let food1 = p.eat(Meat(weight: 1.2, desc: "meat"))print("eat \(food1.desc), weight \(food1.weight)")// eat meat, weight 1.2let food2 = p.eat(Vegetable(weight: 0.8, desc: "meat"))print("eat \(food2.desc), weight \(food2.weight)")// eat meat, weight 0.8]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 终端配置：fish + omf]]></title>
    <url>%2FMac-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9Afish-omf.html</url>
    <content type="text"><![CDATA[安装与配置 fish根据官网：https://fishshell.com/ 指引安装即可。 安装完之后，使用命令sudo vim /etc/shells打开配置文件，在文末加上/usr/local/bin/fish，保存退出。 运行chsh -s /usr/local/bin/fish命令使fish成为默认 shell。 使用fish_config配置主题，这里我选Solarized Dark。 安装 oh my fishcurl -L https://get.oh-my.fish | fish 安装之后，使用omf install eclm主题即可。 其它终端描述文件： https://github.com/altercation/solarized 下载后导入名为 Solarized Dark ansi 的配置文件。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 查看某个文件的修改历史]]></title>
    <url>%2FGit-%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2.html</url>
    <content type="text"><![CDATA[查看某文件的修改记录git lg [filename] 查看某文件所有变更历史git lg -p [filename] 查看某文件在某次提交中的变更历史git show &lt;commit-id&gt; [filename] 恢复某个文件至某个版本git checkout &lt;commit-id&gt; [filename] lg = log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 运算符的重载和自定义]]></title>
    <url>%2FSwift-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89.html</url>
    <content type="text"><![CDATA[1. 运算符的重载1.1 基本运算符的重载1234567891011func * (lhs: String, rhs: Int) -&gt; String &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125;let t = "abc"print(t * 3)// print "abcabcabc" 如上所示，我们重载了运算符 * 。再看看另一个例子： 123struct Vector2D &#123; var x = 0.0, y = 0.0&#125; 我们定义了如上的结构体，如果想把两个 Vector2D 类型的实例相加，编译器是会报错的。如果我们重载操作符 + ，就可以实现相加： 1234567func + (lhs: Vector2D, rhs: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: lhs.x + lhs.x, y: rhs.y + rhs.y)&#125;let first = Vector2D(x: 1.0, y: 2.0)let second = Vector2D(x: 3.0, y: 4.0)print(first + second)// print "Vector2D(x: 4.0, y: 6.0)" 1.2 泛型运算符 1234567func * &lt;T&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125; 按照常理，我们会将第一个例子做如上改写，但是编译器会提示 Binary operator ‘+=’ cannot be applied to two ‘T’ operands ，这是因为 T 类型并不能直接使用加法符合运算符，我们可以通过让 T 类型遵循实现了加法功能的协议来解决这个问题，改写后的代码如下： 1234567891011121314151617protocol Type &#123; static func + (lhs: Self, rhs: Self) -&gt; Self static func += (lhs: inout Self, rhs: Self)&#125;extension String: Type &#123;&#125;extension Int: Type &#123;&#125;extension CGFloat: Type &#123;&#125;func * &lt;T: Type&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123;// result = result + lhs result += lhs &#125; return result&#125; 2. 运算符的自定义先介绍 Swift 中的三个关键字： prefix：前缀运算符，比如 ++i 中的 ++ postfix：后缀运算符，比如 i++ 中的 ++ infix：中缀运算符，比如 a + b 中的 + 这里仅以 infix 为例示范其用法，现在我们自定义一个运算符 ** 和符合运算符 **= ，实现第一个例子的功能。 12345678910111213141516171819202122infix operator **func ** &lt;T: Type&gt; (lhs: T, rhs: Int) -&gt; T &#123; var result = lhs for _ in 1..&lt;rhs &#123; result += lhs &#125; return result&#125;infix operator **=func **= &lt;T: Type&gt; (lhs: inout T, rhs: Int) &#123; lhs = lhs ** rhs&#125;let t = "abc"let s = t ** 3print(s)// print "abcabcabc"var u = "abc"u **= 3print(u)// print "abcabcabc" 至此，运算符的重载和自定义的基本功能就介绍完毕了。当然，自定义运算符同样是可以定义优先级和结合性的，这里不做过多讲解，有兴趣的朋友可以自行查阅资料。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift 编译器提示 TODO 和 FIXME]]></title>
    <url>%2FSwift-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8F%90%E7%A4%BA-TODO-%E5%92%8C-FIXME.html</url>
    <content type="text"><![CDATA[Build Phases，点击 +，添加 New Run Script Phase，添加如下内容： 123TAGS="TODO:|FIXME:"echo "searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;"find "$&#123;SRCROOT&#125;" \( -name "*.swift" \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/" 在代码处添加如下标记：12// TODO: something to do// FIXME: fix bug 编译器会自动给出相应的警告，并且可以快速定位到相应的代码处。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 终端配置：oh-my-zsh + Solarized 配色方案]]></title>
    <url>%2FMac-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%9Aoh-my-zsh-Solarized-%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88.html</url>
    <content type="text"><![CDATA[1. 安装 oh-my-zsh2. 下载solarized3. 打开终端 -&gt; 偏好设置 -&gt; 描述文件 -&gt; 导入文件，导入 solarized/osx-terminal.app-colors-solarized/Solarized Dark ansi.terminal，设置通用下的默认描述文件为Solarized Dark ansi。 4. 附：git log 配置：终端运行：1git config --global alias.lg "log --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset'" 重启终端即可。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
</search>
